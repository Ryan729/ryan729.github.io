{"meta":{"title":"Ryan Shang","subtitle":"生死看淡，不服就干","description":"前端渣渣一枚，热爱科技，热爱搞事请","author":"Ryan Shang","url":"https://www.ryanshang.com","root":"/"},"pages":[{"title":"分类","date":"2017-10-10T11:31:11.000Z","updated":"2018-08-11T10:21:50.168Z","comments":true,"path":"categories/index.html","permalink":"https://www.ryanshang.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2017-10-10T11:24:29.000Z","updated":"2018-08-11T10:21:50.169Z","comments":true,"path":"tags/index.html","permalink":"https://www.ryanshang.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"WSL2设置镜像网络模式","slug":"WSL2设置镜像网络模式","date":"2024-01-05T16:00:00.000Z","updated":"2024-01-09T22:42:48.612Z","comments":true,"path":"2024/01/06/WSL2设置镜像网络模式/","link":"","permalink":"https://www.ryanshang.com/2024/01/06/WSL2%E8%AE%BE%E7%BD%AE%E9%95%9C%E5%83%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/","excerpt":"一、背景WSL2在去年下半年时候更新了2.0的Pre-Relese版本，详细更新内容：https://github.com/microsoft/WSL/releases/tag/2.0.0 总结一下主要是： 支持自动回收内存 支持自动释放 WSL2 虚拟硬盘空间 支持和 Windows 使用相同的网络（镜像网络） 支持 DNS Tunneling 支持 Windows 设置的代理 支持 Windows 防火墙 支持 Multicast 终于，WSL2可以和宿主机的Windows共用一套网络端口了。","text":"一、背景WSL2在去年下半年时候更新了2.0的Pre-Relese版本，详细更新内容：https://github.com/microsoft/WSL/releases/tag/2.0.0 总结一下主要是： 支持自动回收内存 支持自动释放 WSL2 虚拟硬盘空间 支持和 Windows 使用相同的网络（镜像网络） 支持 DNS Tunneling 支持 Windows 设置的代理 支持 Windows 防火墙 支持 Multicast 终于，WSL2可以和宿主机的Windows共用一套网络端口了。 之前的的方式是使用桥接模式给WSL2配置静态IP，现在可以设置镜像网络，直接通过127.0.01来访问WSL2中的服务。这样也能解决当网络环境变化时候，需要重新配置IP的问题。 Note： Windows系统版本需要至少 Windows 11 23H2 WSL最新正式版本为2.0.14 二、配置过程1. 在Windows宿主机上修改WSL的config在当前用户目录(C:\\Users\\xxx)下修改.wslconfig，内容： 123456789101112[wsl2]# networkingMode=bridged# vmSwitch=Home # 此处的名称和指定的虚拟网络交换机一致# dhcp=false # 禁用DHCP，在WSL2系统中通过设置Linux的静态IP实现获取IPnetworkingMode = mirrored # 端口自动转发，Windows和WSL共享端口，都使用127.0.0.1dnsTunneling = true # WSL的DNS请求通过Windows转发firewall = true # WSL同步Windows防火墙规则autoProxy = false # Windows设置代理时自动同步给WSL[experimental]sparseVhd = true # 自动清理磁盘空间autoMemoryReclaim = disabled # 可以在gradual 、dropcache 、disabled之间选择，开启会造成WSL中Docker启动异常 Note： 如果你在WSL里使用docker，需要将 autoMemoryReclaim配置为dropcache或者disabled否则无法启动Docker 如果你在WSL里使用docker，需要在&#x2F;etc&#x2F;docker&#x2F;daemon.json 里添加一句 “iptables”: false，否则你可能无法在Windows中连接Docker容器。 2. 在WSL2中增加网络相关的配置修改下WSL2下/etc/wsl.conf，修改内容： 123[network]generateResolvConf = truegenerateHosts = true 4. 在WSL2中配置DHCP自动获取IP修改WSL2下的/etc/network/interfaces，修改内容： 123456789101112# The primary network interface# 开机自动连接网络auto eth0allow-hotplug eth0 iface eth0 inet dhcp# 注释掉wsl bridged配置# auto eth0# iface eth0 inet static# address 192.168.3.2# netmask 255.255.255.0# gateway 192.168.3.1 5. 重新启动WSL2在powershell中输入： 1wsl --shutdown 再次打开WSL2，使用ip addr命令查看IP地址，已经和宿主机Windows的IP一致了： 12343: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff inet 192.168.3.3/24 brd 192.168.3.255 scope global noprefixroute eth1 valid_lft forever preferred_lft forever 已经成功设置完成。 三、端口冲突问题配置完成后，发现docker中在运行的服务有些挂掉了，重启提示端口冲突，在Windows中使用netstat -aon | findstr &quot;3306&quot;查看进程，也没有查到相关端口。 1. 原因查阅资料后发现，这个问题的原因分为两部分： Windows 中有一个TCP 动态端口范围，处在这个范围内的端口，有时候会被一些服务占用。在 Windows Vista（或 Windows Server 2008）之前，动态端口范围是 1025 到 5000；在 Windows Vista（或 Windows Server 2008）之后，新的默认起始端口为 49152，新的默认结束端口为 65535。 如果安装了 Hyper-V，那么 Hyper-V 会为容器宿主网络服务（Windows Container Host Networking Service）随机保留一些端口号使用。 正常情况下，Hyper-V 虽然会在TCP 动态端口范围中随机挑一些端口号保留（占用），不过保留的端口号普遍比较大，就算保留几百、几千个也影响不大。但是，Windows 自动更新有时会出错，导致这个范围的起始端口被重置为 1024。这就会导致一些常用端口因为被保留而无法使用。 使用命令 netsh int ipv4 show dynamicport tcp 可以查看目前TCP 动态端口的范围： 12345协议 tcp 动态端口范围---------------------------------启动端口 : 1024端口数 : 13977 这只是一个待选择范围，并不代表其中的所有端口都会被保留，只是有一部分会被 Hyper-V 征用。使用 netsh int ipv4 show excludedportrange protocol=tcp 命令可以查看当前所有已经被征用了的端口： 123456789协议 tcp 端口排除范围开始端口 结束端口---------- -------- 3296 3334 5357 5357 27339 27339 50000 50059 这些端口有时候会随机到一些常用端口，比如3000、3306、8080等，导致这些常用端口无法使用。 2. 解决方案可以通过重启网络来重设随机预留的端口，但是这就和开盲盒一样，随机性太高。正确的解决思路，因该是调整TCP 动态端口范围，避开常用的端口区间。 使用管理员权限运行Powershell，执行： 12345netsh int ipv4 set dynamic tcp start=50000 num=15536netsh int ipv6 set dynamic tcp start=50000 num=15536# 重启网络net stop winnatnet start winnat 把TCP 动态端口范围限定在50000-65535，重启网络，再次查看目前TCP 动态端口的范围： 12345协议 tcp 动态端口范围---------------------------------启动端口 : 50000端口数 : 15536 这样就可以成功避开日常使用的端口，保证不会因为端口冲突导致docker等服务无法运行的问题。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://www.ryanshang.com/categories/Windows/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"WSL","slug":"WSL","permalink":"https://www.ryanshang.com/tags/WSL/"}]},{"title":"HTTPS泛域名证书升级并配置HTTP2和TLS1.3","slug":"HTTPS泛域名证书升级并配置HTTP2和TLS1-3","date":"2023-12-22T16:00:00.000Z","updated":"2024-01-07T11:58:50.432Z","comments":true,"path":"2023/12/23/HTTPS泛域名证书升级并配置HTTP2和TLS1-3/","link":"","permalink":"https://www.ryanshang.com/2023/12/23/HTTPS%E6%B3%9B%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6%E5%8D%87%E7%BA%A7%E5%B9%B6%E9%85%8D%E7%BD%AEHTTP2%E5%92%8CTLS1-3/","excerpt":"一、背景最近想给自己的站点都加上HTTPS，以前使用certbot都是给每个域名单独申请证书，比较麻烦，这次升级成泛域名证书，所有同一级域名的站点都可以公用一个证书。刚好也趁此机会把站点的HTTP2.0和TLS1.3都配置上。 二、使用acme.sh申请泛域名证书1. 创建阿里云RAM角色泛域名证书的申请，需要配置特定的DNS来验证域名的归属。如果想实现自动化申请、续期，就需要使用DNS Api来配合使用。","text":"一、背景最近想给自己的站点都加上HTTPS，以前使用certbot都是给每个域名单独申请证书，比较麻烦，这次升级成泛域名证书，所有同一级域名的站点都可以公用一个证书。刚好也趁此机会把站点的HTTP2.0和TLS1.3都配置上。 二、使用acme.sh申请泛域名证书1. 创建阿里云RAM角色泛域名证书的申请，需要配置特定的DNS来验证域名的归属。如果想实现自动化申请、续期，就需要使用DNS Api来配合使用。 acme.sh支持使用阿里云的DNS Api。 进入阿里云控制台，选择云管理——访问控制（RAM访问控制）——身份管理——用户——创建用户 创建成功后会获得这个用户的Key和Secret，需要记录下来，在申请证书时需要。 创建的新用户需要赋予几个权限： 管理云解析（DNS）的权限 管理公共DNS（PubDNS）的权限 管理HTTPDNS的权限 配置好后，就可以继续申请证书的操作了。 2. 安装acme.shNote： 官方建议使用root用户安装，也可以使用其他用户，这里以root用户为例 安装 acme.sh ，默认安装位置是 ~&#x2F;.acme.sh : 1curl https://get.acme.sh | sh 在这一步安装过程中，完成了3个任务： 拷贝sh脚本到~&#x2F;.acme.sh&#x2F; 创建alias别名acme.sh&#x3D;~&#x2F;.acme.sh&#x2F;acme.sh 启动定时器，并加入到定时任务 3. 配置阿里云的DNS信息在终端输入： 12export Ali_Key=&quot;ali-key&quot;export Ali_Secret=&quot;ali-secret&quot; 这个DNS API信息最终会保存在~/.acme.sh/account.conf文件中。 4. 申请泛域名证书在终端输入： 1acme.sh --issue --dns dns_ali -d xxx.com -d *.xxx.com --server letsencrypt --dns dns_ali是指使用的阿里云的DNS Api，不同云服务商不一致 --server letsencrypt是指使用letsencrypt申请证书，不携带参数默认使用的zerossl，我使用默认会报错，更换为letsencrypt可正常申请。 证书申请成功后，默认保存在~/.acme.sh/xxx.com目录下。 5. 安装证书到指定目录默认生成的证书都放在安装目录下, 不建议直接通过nginx或apache使用此目录下的证书。正确的使用方法是使用 --install-cert 命令，并指定目标位置,，然后证书文件会被copy到相应的位置。 在nginx的配置文件中创建一个目录用来保存证书，也可以保存在其他位置，看个人使用习惯。 1234cd /etc/nginxmkdir cacd camkdir xxx.com 安装证书： 1234acme.sh --install-cert -d xxx.com \\--key-file /etc/nginx/ca/xxx.com/key.pem \\--fullchain-file /etc/nginx/ca/xxx/cert.pem \\--reloadcmd &quot;service nginx reload&quot; 上述命令把下发的证书复制到你指定的位置，这样避免你直接从~/.acme.sh/读取证书，然后重新加载nginx或apache以刷新证书。域名为必需参数，其它参数为可选。 但要注意的是，reloadcmd参数非常重要（reloadcmd后面的参数为重新加载nginx或Apache的命令，可以根据系统的不同作相应修改），即使更新了证书，但是nginx或apache没有重新加载，证书是不是会刷新到服务中去的。 6. 调整nginx配置修改站点的nginx证书配置，例如：/etc/nginx/conf.d/blog.conf，把证书更换为刚申请的泛域名证书。 12345678910111213server &#123; listen 443 ssl; server_name blog.xxx; charset utf-8; location / &#123; root /home/git/blog; index index.html; &#125; ssl_certificate /etc/nginx/ca/xxx.com/cert.pem; ssl_certificate_key /etc/nginx/ca/xxx.com/key.pem; ...&#125; 先执行nginx -t，验证配置文件是否有问题，确认没有问题后执行systemctl reload nginx，更新nginx配置。这时候访问页面，查看证书信息就能确认证书是否成功生效。 三、配置HTTP2和TLS1.3站点的nginx配置全部更新后，就可以配置下HTTP2和TLS1.3了，这个操作比较简单。使用sed命令可以批量操作。 Note：此处修改最好提前备份下配置文件，防止操作异常导致站点访问异常。 1234sed -i &#x27;s/listen 443 ssl;/listen 443 ssl;\\ http2 on;/&#x27; /etc/nginx/conf.d/*.conf # 在listen 443 ssl；这一行的下面增加http2的配置sed -i &#x27;s/ssl_protocols TLSv1 TLSv1.1 TLSv1.2;/ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3;&#x27; /etc/nginx/conf.d/*.conf # 把配置中的支持协议替换掉，顺便下线了TLS1 先执行nginx -t，验证配置文件是否有问题，确认没有问题后执行systemctl reload nginx，更新nginx配置。 访问页面，可在开发者工具的network中查看h2配置是否成功，在security中查看是否开启了TLS1.3。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"}],"tags":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.ryanshang.com/tags/HTTPS/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.ryanshang.com/tags/Nginx/"}]},{"title":"CSS切换主题方案","slug":"CSS切换主题方案","date":"2023-08-26T16:00:00.000Z","updated":"2024-01-09T22:40:51.547Z","comments":true,"path":"2023/08/27/CSS切换主题方案/","link":"","permalink":"https://www.ryanshang.com/2023/08/27/CSS%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98%E6%96%B9%E6%A1%88/","excerpt":"一、背景在最近的一个需求中，一个商业产品要在不同APP中需要使用不同的CSS主题，这就涉及到了动态切换CSS主题的方案 二、方案简介sass+mixin+js设置html的data-theme属性原理是使用sass配合mixin编程成固定的css，通过js设定不同的主题，使对应的css生效 1. 定义变量","text":"一、背景在最近的一个需求中，一个商业产品要在不同APP中需要使用不同的CSS主题，这就涉及到了动态切换CSS主题的方案 二、方案简介sass+mixin+js设置html的data-theme属性原理是使用sass配合mixin编程成固定的css，通过js设定不同的主题，使对应的css生效 1. 定义变量使用sass的map，可以把所涉及到的变量通过配置的方式整理起来，其中第一层是主题名，第二层是css的value，例如bg、info-price 12345678910111213141516@use &quot;sass:map&quot;;$themes: ( appA: ( bg: url(&#x27;https://wos.58cdn.com.cn/cDazYxWcDHJ/picasso/2m9p9qlv__w1500_h520.png&#x27;) no-repeat 0 0px / 100%, info-price: #FF552E, ), appB: ( bg: url(&#x27;https://wos.58cdn.com.cn/cDazYxWcDHJ/picasso/muc3req9__w1500_h520.png&#x27;) no-repeat 0 0px / 100%, info-price: #09D57E, ), appC: ( bg: url(&#x27;https://wos.58cdn.com.cn/cDazYxWcDHJ/picasso/7re7pg8r__w1500_h520.png&#x27;) no-repeat 0 0px / 100%, info-price: #FF704F, ),); 2. mixin方法的实现通过mixin实现把css根据不同主题注入页面 123456789101112131415161718192021@use &quot;sass:map&quot;;// 遍历主题数据，把@content中的css注入页面中@mixin injectCss &#123; @each $theme-name, $theme-map in $themes &#123; //!global 把局部变量强升为全局变量，让下方的setCss方法也可以使用$theme-map $theme-map: $theme-map !global; //判断html的data-theme的属性值 #&#123;&#125;是sass的插值表达式 //&amp; sass嵌套里的父容器标识 @content是混合器插槽，像vue的slot [data-theme=&quot;#&#123;$theme-name&#125;&quot;] &amp; &#123; @content; &#125; &#125;&#125;// 注入css@mixin setCss($css, $variable) &#123; @include injectCss &#123; #&#123;$css&#125;: map-get($theme-map, $variable); &#125;&#125; 3. 通过js设置主题1234567const app = utils.getApp();const themeMap = &#123; appA: &#x27;appA&#x27;, appB: &#x27;appB&#x27;, appC: &#x27;appC&#x27;,&#125;; window.document.documentElement.setAttribute(&#x27;data-theme&#x27;, themeMap[app] || &#x27;appA&#x27;); 4. 在页面中使用mixin12345@import &#x27;@css/m/mini-theme.scss&#x27;;.buy-container &#123; @include setCss(&quot;background&quot;, &quot;bg&quot;);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"}]},{"title":"页面通过webview方式接入微信小程序记录","slug":"页面通过webview方式接入微信小程序记录","date":"2023-07-27T16:00:00.000Z","updated":"2024-01-05T22:48:06.141Z","comments":true,"path":"2023/07/28/页面通过webview方式接入微信小程序记录/","link":"","permalink":"https://www.ryanshang.com/2023/07/28/%E9%A1%B5%E9%9D%A2%E9%80%9A%E8%BF%87webview%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%AE%B0%E5%BD%95/","excerpt":"一、背景近期接到招聘小程序要内嵌商业产品的需求，这里大致记录下一些接入过程中涉及到的要点 二、差异点先说下小程序中的webview和普通h5页面的差异点 1. cookie的问题","text":"一、背景近期接到招聘小程序要内嵌商业产品的需求，这里大致记录下一些接入过程中涉及到的要点 二、差异点先说下小程序中的webview和普通h5页面的差异点 1. cookie的问题小程序中的cookie和小程序webview中的cookie不共享 2. 小程序webview中只能使用部分微信jssdk的功能具体参考：微信小程序webview页面支付功能不在其中，按照微信要求不能在当前页面中直接调用微信支付，需要跳转到一个微信小程序原生页面来进行支付操作 三、接入要点1. 登录态在URL中增加登录票据，由前端获取后通过js注入cookie 2. 支付功能的调整整体方案：在小程序中新增一个专用充值页面，业务页面（小程序webview内嵌页面）需要充值时，携带参数跳转到小程序充值页面，充值完成后再跳回到业务页面具体流程： 用户选择商业产品的套餐 业务前端发送用户选择数据和当前场景（微信小程序）等信息给业务后端 业务后端获取数据后，处理充值参数，然后调用PMC获取充值参数的接口，获取充值参数返回给业务前端 业务前端把参数拼接到小程序路由，跳转到小程序充值页面 小程序充值页面充值完成后，跳转回业务页面 3. 在小程序管理后台中配置域名在小程序的webview中访问页面需要配置两种域名： 服务器域名：接口请求、CDN静态资源等的域名，平时的小程序开发就需要配置，这里不再赘述 业务域名：在webview中打开需要配置的域名，针对需要再小程序使用webview内嵌的场景，除了在小程序后台配置域名外，还需要进行域名验证，让微信确认此域名是你拥有。 业务域名验证方式：在业务域名根路径下增加微信提供的文件，里面包含验证的加密串。 方案： 可在域名对应集群下增加静态资源托管 可在nginx层根据location分流由nginx层托管。 4. 页面路由常见处理逻辑兼容微信JSSDK：https://res.wx.qq.com/open/js/jweixin-1.6.0.js 页面路由会退：window.wx.navigateBack();关闭当前页面：window.wx.miniProgram.navigateBack();","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.ryanshang.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"更稳定的使用Homebrew","slug":"更稳定的使用Homebrew","date":"2023-06-23T16:00:00.000Z","updated":"2024-01-05T22:48:06.141Z","comments":true,"path":"2023/06/24/更稳定的使用Homebrew/","link":"","permalink":"https://www.ryanshang.com/2023/06/24/%E6%9B%B4%E7%A8%B3%E5%AE%9A%E7%9A%84%E4%BD%BF%E7%94%A8Homebrew/","excerpt":"HomebrewHomebrew一直是Mac上受欢迎的包管理工具之一，日常开发工作中可能会用到他。但是因为Homebrew的仓库使用的是github，使用起来不是很稳定。最近对homebrew进行了重装升级，这里记录下找到的两种可以稳定使用的方法。 1. 终端代理如果个人有稳定的代理，可以在终端中配置使用代理。这个方案能保证和homebrew的更新内容保持一致，但是有一定使用成本。在.bashrc&#x2F;.zshrc中增加代理配置，参考代码如下： 1234567891011# proxyproxy-on () &#123; export http_proxy=&quot;http://127.0.0.1:7890&quot; export https_proxy=&quot;http://127.0.0.1:7890&quot; echo &quot;Proxy On&quot;&#125;proxy-off () &#123; unset http_proxy unset https_proxy echo &quot;Proxy Off&quot;&#125;","text":"HomebrewHomebrew一直是Mac上受欢迎的包管理工具之一，日常开发工作中可能会用到他。但是因为Homebrew的仓库使用的是github，使用起来不是很稳定。最近对homebrew进行了重装升级，这里记录下找到的两种可以稳定使用的方法。 1. 终端代理如果个人有稳定的代理，可以在终端中配置使用代理。这个方案能保证和homebrew的更新内容保持一致，但是有一定使用成本。在.bashrc&#x2F;.zshrc中增加代理配置，参考代码如下： 1234567891011# proxyproxy-on () &#123; export http_proxy=&quot;http://127.0.0.1:7890&quot; export https_proxy=&quot;http://127.0.0.1:7890&quot; echo &quot;Proxy On&quot;&#125;proxy-off () &#123; unset http_proxy unset https_proxy echo &quot;Proxy Off&quot;&#125; 这样在需要使用代理的场景下，可以在终端中使用下列命令开启代理： 1$ proxy-on 不需要使用代理的场景，可以使用在终端中使用下列命令关闭代理： 1$ proxy-off 二、配置镜像源Homebrew使用镜像源也是一种方式，最近版本的Homebrew对镜像源进行了更新，已经支持直接通过镜像源的方式进行安装，也有了更优雅的镜像源配置方式。这个方案使用起来成本更低，但是少数时候会发生源出现问题导致使用异常的情况。 使用镜像源安装： export HOMEBREW_API_DOMAIN&#x3D;”https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api“export HOMEBREW_BOTTLE_DOMAIN&#x3D;”https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles“export HOMEBREW_BREW_GIT_REMOTE&#x3D;”https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git“export HOMEBREW_CORE_GIT_REMOTE&#x3D;”https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git“ 使用官方安装脚本&#x2F;bin&#x2F;bash -c “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)” 或者使用镜像源安装脚本git clone –depth&#x3D;1 https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/install.git brew-install&#x2F;bin&#x2F;bash brew-install&#x2F;install.shrm -rf brew-install参考链接：https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/ 这样就能更加稳定的使用Homebrew了。","categories":[{"name":"Mac","slug":"Mac","permalink":"https://www.ryanshang.com/categories/Mac/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://www.ryanshang.com/tags/Homebrew/"}]},{"title":"node-sass安装问题记录","slug":"node-sass安装问题记录","date":"2022-11-18T16:00:00.000Z","updated":"2024-01-05T22:48:06.141Z","comments":true,"path":"2022/11/19/node-sass安装问题记录/","link":"","permalink":"https://www.ryanshang.com/2022/11/19/node-sass%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/","excerpt":"一、背景最近新接手了一个老项目，在启动项目阶段遇到了安装node-sass依赖的问题，这里简单记录下解决方案。 二、执行npm install node-sass时发生了什么？ 如果本地有缓存命中，则安装本地缓存 npm 拉下 node-sass包 根据node版本，从github下载对应的binding.node编译器 如果下载编译器失败或github没有对应node版本的编译器资源则尝试本地编译 使用python2进行本地编译 三、常见问题","text":"一、背景最近新接手了一个老项目，在启动项目阶段遇到了安装node-sass依赖的问题，这里简单记录下解决方案。 二、执行npm install node-sass时发生了什么？ 如果本地有缓存命中，则安装本地缓存 npm 拉下 node-sass包 根据node版本，从github下载对应的binding.node编译器 如果下载编译器失败或github没有对应node版本的编译器资源则尝试本地编译 使用python2进行本地编译 三、常见问题安装过程中，经常会安装失败，常见的问题有： 无法稳定的访问github导致下载binding.node资源失败，需要本地编译 本地使用的node版本没有对应的binding.node编译器，需要本地编译 mac12.3之后默认移除了apple command-line-tools中的python2，导致本地编译的时候确实环境导致失败 四、解决方案其实问题最主要的原因就是无法下载编译好的binding.node资源，所以解决这个问题的优先思路就是保证能下载到编译好的binding.node资源，尽可能不进行本地编译（过于耗时）。 解决步骤： 1. 使用镜像源在项目中增加.npmrc，给node-sass的编译器配置镜像源，确保binding.node资源能够下载成功 1sass_binary_site=http://cdn.npm.taobao.org/dist/node-sass 2. 使用特定node版本根据项目中node-sass的版本，在github上找到对应的node版本，确保能从github&#x2F;加速源下载到编译好的binding.node资源具体版本可以参考：Node-Sass Node version support policy 这个只是面对老项目时，临时安装node-sass的解决方案，最终的解决方案，是使用dart-sass替换node-sass。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://www.ryanshang.com/tags/npm/"},{"name":"node-sass","slug":"node-sass","permalink":"https://www.ryanshang.com/tags/node-sass/"}]},{"title":"WSL2设置静态IP","slug":"WSL2设置静态IP","date":"2022-10-22T16:00:00.000Z","updated":"2024-01-07T11:58:50.416Z","comments":true,"path":"2022/10/23/WSL2设置静态IP/","link":"","permalink":"https://www.ryanshang.com/2022/10/23/WSL2%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP/","excerpt":"一、背景1. 简介微软的WSL(Windows Subsystem for Linux)是近几年我觉得对开发者最友好的功能之一，已经有了WSL1和WSL2两个不同的版本 WSL1：用模拟Linux内核API的方式实现一个Linux环境优点：和Windows宿主系统之间之间网络共享更加无缝，包括共享端口，共享文件系统等缺点：底层内核并不是原生Linux内核，所以在一些更底层的开发上有区别，并且可能无法随着Linux内核更新而更新","text":"一、背景1. 简介微软的WSL(Windows Subsystem for Linux)是近几年我觉得对开发者最友好的功能之一，已经有了WSL1和WSL2两个不同的版本 WSL1：用模拟Linux内核API的方式实现一个Linux环境优点：和Windows宿主系统之间之间网络共享更加无缝，包括共享端口，共享文件系统等缺点：底层内核并不是原生Linux内核，所以在一些更底层的开发上有区别，并且可能无法随着Linux内核更新而更新 WSL2：使用Windows自己的Hyper-V虚拟技术虚拟化了一个Linux环境，类似于使用VirtualBox等虚拟机优点：原生Linux，完全和Linux一致缺点：和宿主机天然隔离，通过网络访问相互文件，跨文件系统的IO低 2. 个人选择个人偏向使用WSL2，更加原生的Linux，并且利用虚拟机天然的隔离机制，把开发和娱乐环境分离，互不干扰 3. 现阶段问题WSL2现阶段使用最大的一个问题是每次重启电脑，会分配新的IP，因为默认使用的是Hyper-V的NAT模式，请求会通过Hyper-V的交换机，由宿主系统转发出去。因为这个IP会变，想访问WSL2中的服务，就需要每次关注IP的变化，之前是通过github上一个小工具，在每次WSL2启动时，获取WSL2的IP，向Windows宿主机的hosts写入一个域名。但是不够方便，而且随着版本Windows的版本更新，时不时会出现bug。 二、解决方案通过网上查阅资料，发现可以通过给Hyper-V增加一个交换机让WSL2使用，走桥接模式，设置一个固定的IP，这样就能满足自己的需要了。原理就相当于，对家里的路由器来说，把WSL2变成和宿主机Windows一个级别的设备，不再走NAT模式。 1. 在Windows宿主机增加Hyper-V交换机系统: Windows 11 Pro打开Hyper-V管理器，选择右侧的虚拟交换机管理器，新建虚拟网络交换机，选择外部网络。添加完成如下图： 2. 在Windows宿主机上增加WSL的config在当前用户目录(C:\\Users\\xxx)下增加.wslconfig，内容： 1234[wsl2]networkingMode=bridgedvmSwitch=Home # 此处的名称和指定的虚拟网络交换机一致dhcp=false # 禁用DHCP，在WSL2系统中通过设置Linux的静态IP实现获取IP 3. 在WSL2中增加网络相关的配置系统: Debian修改下WSL2下/etc/wsl.conf，修改内容： 1234# wsl bridged[network]generateResolvConf = false # 禁止启动WSL2时生成/etc/resolv.confgenerateHosts = false # 禁止启动WSL2时修改/etc/hosts 4. 在WSL2中设置静态IP修改WSL2下的/etc/network/interfaces，修改内容： 123456789101112# The primary network interface# 开机自动连接网络# auto eth0 # 注释掉# allow-hotplug eth0 # 注释掉# iface eth0 inet dhcp # 注释掉# 增加wsl bridged配置，设置静态IPauto eth0iface eth0 inet static address 192.168.3.2 # 设置的静态IP netmask 255.255.255.0 # 子网掩码 gateway 192.168.3.1 # 路由器的IP 5. 重新启动WSL2在powershell中输入： 1wsl --shutdown 再次打开WSL2，使用ip addr命令查看IP地址： 12342: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000 link/ether xx:xx:xx:xx:xx:xx brd ff:ff:ff:ff:ff:ff inet 192.168.3.2/24 brd 192.168.3.255 scope global eth0 valid_lft forever preferred_lft forever 已经成功设置完成。 三、方案不足设置的IP和网络环境相关，如果更换一个网络环境，例如，从家里到公司，就需要重新配置了。 所以，这个方案更适合台式机这种不怎么移动的场景。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://www.ryanshang.com/categories/Windows/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"WSL","slug":"WSL","permalink":"https://www.ryanshang.com/tags/WSL/"}]},{"title":"移动端开调试——Charles","slug":"移动端开调试——Charles","date":"2022-06-17T16:00:00.000Z","updated":"2024-01-07T11:58:50.342Z","comments":true,"path":"2022/06/18/移动端开调试——Charles/","link":"","permalink":"https://www.ryanshang.com/2022/06/18/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E8%B0%83%E8%AF%95%E2%80%94%E2%80%94Charles/","excerpt":"一、简介 1Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information). Charles是移动端开发时候比较常见的抓包工具： Web调试代理工具 可用于Http&#x2F;Https接口获取Request&#x2F;Reponse信息 可用于手机抓包","text":"一、简介 1Charles is an HTTP proxy / HTTP monitor / Reverse Proxy that enables a developer to view all of the HTTP and SSL / HTTPS traffic between their machine and the Internet. This includes requests, responses and the HTTP headers (which contain the cookies and caching information). Charles是移动端开发时候比较常见的抓包工具： Web调试代理工具 可用于Http&#x2F;Https接口获取Request&#x2F;Reponse信息 可用于手机抓包 二、PC&#x2F;Mac HTTPS配置1. 安装根证书(1) Mac 在应用的工具栏选择Help—SSL Proxying—Install Charles Root Certificate 输入本机密码安装证书（注意需要安装为系统证书） 打开Mac的“钥匙串访问”程序，选择系统，找到Charles Proxy CA一项，双击打开 点击信任，然后全部改为“始终信任” 重启Charles 在应用的工具栏选择Proxy—macOS Proxy即可对Mac进行抓包 (2) PC 在应用的工具栏选择Help—SSL Proxying—Install Charles Root Certificate 在弹出的“证书”页面，选择“安装证书” 选择“本地计算机”，点击“下一页”（需要管理员权限） 选择“将所有的证书都放入下列存储”，点击“浏览”，选择“收信人的根证书颁发机构”，点击“确认”，点击“下一页” 点击“完成” 重启Charles 在应用的工具栏选择Proxy—Windows Proxy即可对Windows进行抓包 2. 配置Https 在应用的工具栏选择Proxy—SSL Proxying Settings 勾选“Enable SSL Proxying” 在Include下点击“Add” Host输入通配符(*)，Port输入443，点击“OK” 点击“OK” 三、iOS&#x2F;Android配置1. 下载手机证书(1) iOS 打开iOS的“设置”—无线局域网—选择和PC&#x2F;Mac同一局域网进行连接 修改当前局域网配置，在http代理项，“配置代理”—手动—输入PC&#x2F;Mac的IP地址（可在Charles—Help—Local IP Address查看），端口号选择8888（默认值），点击右上角“存储” 首次连接PC&#x2F;Mac会提示设备链接，需要确认是“Allow”还是“Deny”，选择“Allow” （可在Charles—Proxy—Access Control Settings管理） 打开Safafi浏览器，输入网址“chls.pro&#x2F;ssl”，提示是否允许下载配置描述文件，选择“允许” 点击“OK” (2) Android 打开Android的“设置”—“WLAN”—选择和PC&#x2F;Mac同一局域网进行连接 修改当前局域网配置，在代理项，选择手动—输入PC&#x2F;Mac的IP地址（可在Charles—Help—Local IP Address查看），端口号选择8888（默认值），保存 首次连接PC&#x2F;Mac会提示设备链接，需要确认是“Allow”还是“Deny”，选择“Allow”（可在Charles—Proxy—Access Control Settings管理） 打开浏览器，输入网址“chls.pro&#x2F;ssl”，下载证书文件 2. 安装手机证书(1) iOS 打开iOS的“设置”—通用—VPN与设备管理—已下载的描述文件—点击“Charles Proxy CA……” 进入安装描述文件页面，点击“安装”，输入锁屏密码安装证书 打开iOS的“设置”—通用—关于本机—证书信任设置 找到安装的“Charles Proxy CA”，开启后面的开关 (2) AndroidAndroid系统的CA证书分为两种：用户证书和系统证书 Android7.0后，Android的APP默认配置只信任系统证书，使用用户证书无法对Https进行抓包 安装CA证书为用户证书（适用于测试包）： 下载证书文件后，打开Android的“设置”，安全—加密与凭据—安装证书—CA证书—选择刚下载的证书文件（不同厂商、不同版本操作步骤可能会有区别） 安装CA证书为系统证书，需要ROOT（适用于正式包）： 把下载的证书转移到PC&#x2F;Mac上，使用openssl x509 -subject_hash_old -in charles-ssl-proxying-certificate.pem计算特征值，比如46f58a05 把证书文件改名为46f58a05.0 把证书放到手机的系统分区中&#x2F;system&#x2F;etc&#x2F;security&#x2F;cacerts&#x2F; 四、常用功能1. Rewrite操作：Charles工具栏—Tools—Rewrite 适用场景：对接口的Req&#x2F;Res进行调整；对HTML进行注入 2. Map Local操作：Charles工具栏—Tools—Map Local 适用场景：本地开发真机调试，build后替换资源；新项目上线前的模板Mock 3. Map Remote操作：Charles工具栏—Tools—Map Remote 适用场景：部分SDK的联调 4. Breakpoints操作：Charles工具栏—Proxy—Breakponits Settings 适用场景：对接口的Req&#x2F;Res进行编辑 五、推荐实践1. 每次调试完成后关闭所有工具操作：每次使用完成后，关闭Map Remote&#x2F;Map Local&#x2F;Rewrite&#x2F;Breakpoints等功能 作用：排除因这些功能造成的异常 2. 设置抓包记录域名白名单操作：在Charles—Proxy—Record Settings设置抓包记录域名白名单 作用：只记录58相关域名，减少其他请求干扰 3. SSL证书绕过Apple域名操作：在Charles—Proxy—SSL Proxying Settings设置SSL代理不包括Apple相关域名： *.apple.com *.itunes.apple.com *.mzstatic.com 作用：抓包时候可以正常访问Apple Store以及苹果内购（也可以通过手机的pac分流实现） 4. 使用Rewrite注入vconsole操作：在Charles—Tools—Rewrite设置给html请求的Response注入vconsole 作用：不需要给项目中增加冗余代码，不需要重新构建，不会影响线上代码 5. 利用Map Local&#x2F;Rewrite模拟一些case操作：利用Map Local&#x2F;Rewrite模拟一些case 作用：不改变代码逻辑的情况对线上接口进行微调（jsonp使用Rewrite）","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Charles","slug":"Charles","permalink":"https://www.ryanshang.com/tags/Charles/"}]},{"title":"使用服务器部署HEXO博客并配置HTTPS","slug":"使用服务器部署HEXO博客并配置HTTPS","date":"2021-11-05T16:00:00.000Z","updated":"2024-01-07T11:58:50.342Z","comments":true,"path":"2021/11/06/使用服务器部署HEXO博客并配置HTTPS/","link":"","permalink":"https://www.ryanshang.com/2021/11/06/%E4%BD%BF%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2HEXO%E5%8D%9A%E5%AE%A2%E5%B9%B6%E9%85%8D%E7%BD%AEHTTPS/","excerpt":"一、背景最近老的服务器过期，购买了新的服务器，需要对原有服务器的服务进行迁移，刚好以前部署博客时没有记录，这里记录下在服务器上部署Hexo博客的过程(假设已有Hexo的git工程)。 二、准备工作1. 大致流程以前为了简单方便，部署时候采用了Hexo的静态博客方案。","text":"一、背景最近老的服务器过期，购买了新的服务器，需要对原有服务器的服务进行迁移，刚好以前部署博客时没有记录，这里记录下在服务器上部署Hexo博客的过程(假设已有Hexo的git工程)。 二、准备工作1. 大致流程以前为了简单方便，部署时候采用了Hexo的静态博客方案。 大致使用流程是： 本地编写Markdown文档 本地Hexo解析成静态页 提交到服务器上的Git或者GitHub等多仓库 Nginx对外服务 用户访问 2. 相关环境域名： 配置好DNS解析，例如：blog.xxx.com，指向服务器ip 服务器： Git Nginx PC&#x2F;Mac： Node Git hexo-cli Markdown编辑器 Terminal Hexo工程： 已经创建好的Hexo工程，执行hexo server，可以按照提示访问开发页面 三、部署过程（以root用户为例）1. 给服务器增加git用户1adduser git 2. 配置SSH公钥登录配置SSH公钥登录是为了实现类似在Github中配置公钥可以免密码直接操作Git的效果。 先切换用户，然后创建文件： 12345su git # 切换到git用户cd ~ # 切换刀git用户的主文件夹mkdir .ssh # 创建.ssh文件夹cd .ssh # 切换刀.ssh文件夹touch authorized_keys # 创建ssh访问公钥文件 编辑/home/git/.ssh/authorized_keys，配置公钥，这里不做额外赘述。 修改authorized_keys权限： 12exit # 退出git用户，会回到root用户chmod 644 /home/git/.ssh/authorized_keys # 调整文件权限 3. 创建Git仓库并且配置Git Hooks创建一个Git裸库（用于保存Hexo构建后的代码）： 123su git # 切换到git用户cd ~ # 切换刀git用户的主文件夹git init --bare blog.git #建立一个名字叫blog.git的裸库 创建一个临时文件夹，用于Git Hooks操作文件用： 12cd ~ # 切换刀git用户的主文件夹mkdir tmp 配置Git Hooks： 12cd /home/git/blog.git/hooks # 进入git hooks的目录vim post-receive # 编辑钩子内容 post-receive内容： 12345678#!/bin/bashGIT_REPO=/home/git/blog.gitTMP_GIT_CLONE=/home/git/tmp/blogPUBLIC_WWW=/home/git/blogrm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;/*cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125; 切换回root用户，赋予post-receive执行权限： 12exit # 退出git用户，会回到root用户chmod +x /home/git/blog.git/hooks/post-receive 4. 配置nginx在/etc/nginx/conf.d中增加一个配置文件blog.conf： 12cd /etc/nginx/conf.d # 进入nginx站点配置文件夹vim blog.conf # 编辑博客站点配置 站点配置： 12345678server &#123; listen 80; server_name blog.xxx.com; location / &#123; root /home/git/blog; index index.html; &#125;&#125; 保存后执行nginx -s reload重新加载配置。 5. 在Hexo中配置发布信息编辑Hexo工程中的_config.yml，增加： 1234deploy: - type: git repo: git@blog.xxx.com:/home/git/blog.git branch: master 在PC&#x2F;Mac的Hexo工程中，执行构建发布命令： 1hexo c | hexo g | hexo d 正常情况下，执行完成后，hexo会把构建好的页面push到服务器上刚刚新建的裸库中，然后会触发post-receive钩子，把资源拉取到服务器的/home/git/blog目录中。这时候就可以在浏览器中访问blog.xxx.com来查看博客内容了。 四、配置HTTPS（以root用户为例）博客配置好了，下一步当然是配置HTTPS了，这里使用certbot来快速配置https证书。 1. 安装certbot1apt install certbot -y 2. 使用cerbot申请证书123# 使用方法：certbot certonly --webroot -w [Web站点目录] -d [站点域名] -m [联系人email地址] --agree-tos# 例如：sudo certbot certonly --webroot -w /home/git/blog -d blog.xxx.com -m xxx@xxx.com --agree-tos 申请成功会提示： 1234567891011IMPORTANT NOTES: - Congratulations! Your certificate and chain have been saved at /etc/letsencrypt/live/blog.xxx.com/fullchain.pem. Your cert will expire on 2017-03-20. To obtain a new or tweaked version of this certificate in the future, simply run certbot again. To non-interactively renew *all* of your certificates, run &quot;certbot renew&quot; - If you like Certbot, please consider supporting our work by: Donating to ISRG / Let&#x27;s Encrypt: https://letsencrypt.org/donate Donating to EFF: https://eff.org/donate-le 证书的保存位置在： 1/etc/letsencrypt/live/blog.xxx.com/ 3. 调整nginx配置修改/etc/nginx/conf.d/blog.conf： 1234567891011121314151617181920212223242526server &#123;listen 80;server_name blog.xxx.com;rewrite ^ https://$server_name$request_uri? permanent;&#125;server &#123; listen 443 ssl; server_name blog.xxx.com; charset utf-8; root /home/git/blog; index index.html; # letsencrypt生成的文件 ssl_certificate /etc/letsencrypt/live/blog.xxx.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/blog.xxx.com/privkey.pem; ssl_session_timeout 1d; ssl_session_cache shared:SSL:50m; ssl_session_tickets on; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # 一般推荐使用的ssl_ciphers值: https://wiki.mozilla.org/Security/Server_Side_TLS ssl_ciphers &#x27;ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128:AES256:AES:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK&#x27;; ssl_prefer_server_ciphers on;&#125; 保存后执行nginx -s reload重新加载配置。 在浏览器中访问http://blog.xxx.com，就会自动跳转到https://blog.xxx.com了。如果是 chrome 浏览器，在地址栏点击小锁的图标，可以查看证书的详情。 4. 自动更新证书证书是有有效期的，需要再配置下自动更新证书，这样我们就可以不用关心了。 执行crontab -e，增加一行： 12# 每月1号5时执行执行一次更新，并重启nginx服务器00 05 01 * * /usr/bin/certbot renew --quiet &amp;&amp; /bin/systemctl restart nginx 这样在每个月5日的凌晨都会执行一次更新，保证证书不过期。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.ryanshang.com/tags/Git/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.ryanshang.com/tags/HTTPS/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.ryanshang.com/tags/Hexo/"}]},{"title":"一个URL的旅途","slug":"一个URL的旅途","date":"2021-06-25T16:00:00.000Z","updated":"2024-01-07T11:58:50.333Z","comments":true,"path":"2021/06/26/一个URL的旅途/","link":"","permalink":"https://www.ryanshang.com/2021/06/26/%E4%B8%80%E4%B8%AAURL%E7%9A%84%E6%97%85%E9%80%94/","excerpt":"一、前言 为什么要研究这篇内容： 每天都在和浏览器打交道 一道面试题 开拓视野 通过了解一个url的请求发生了什么来了解现代Web服务架构的演进，这里的每一个环节深挖下去都是一个很大的方向，所里这里仅做一个简介，不会深挖每个环节。","text":"一、前言 为什么要研究这篇内容： 每天都在和浏览器打交道 一道面试题 开拓视野 通过了解一个url的请求发生了什么来了解现代Web服务架构的演进，这里的每一个环节深挖下去都是一个很大的方向，所里这里仅做一个简介，不会深挖每个环节。 二、现代Web服务架构的演进1. 基础的样子 用户通过在浏览器输入IP，访问通过存放在服务器中的HTML。 这时候就会有两个问题： 浏览器和服务器如何进行通信？ 客户的内网IP怎么和公网IP进行通信？ (1) 浏览器和服务器如何进行通信？① TCP、UDP和HTTP 这三个关键词可以说是现代Web的基石，现在常说的前后端开发基本上基于的都是TCP、UDP和HTTP，在TCP&#x2F;IP的五层模型中，TCP和UDP属于传输层，HTTP属于应用层，不是很严谨的说，HTTP基于TCP协议。 TCP： 面向连接(网络底层的数据传输)，可靠，慢，资源占用多 三次握手，四次挥手 关于TCP的三次握手，有个很经典的笑话： 123456789「嗯，我想听一个 TCP 的笑话。」「好的，我会给你讲一个TCP 的笑话。」「好的，我会听一个TCP 的笑话。」「你准备好听一个TCP 的笑话么？」「嗯，我准备好听一个TCP 的笑话」「Ok，那我要发 TCP 笑话了。大概有 10 秒，20 个字。」「嗯，我准备收你那个 10 秒时长，20 个字的笑话了。」「抱歉，你的连接超时了。你好，你想听 TCP 的笑话么？」「我给你们讲个 UDP 的笑话吧，哈哈哈哈」 UDP： 无连接，不可靠，快，资源占用少 HTTP： 简单快速、灵活、无状态、无连接(应用层面的沟通交互) ② HTTP的简介HTTP是浏览器中最常见的协议，基本上现在的所有页面都是基于该协议。 HTTP基于TCP，当然也继承了TCP的可靠性，当浏览器和服务器进行通信的时候，也会进行三次握手和四次挥手。 这个过程比较复杂，如果把女朋友当作客户端，把男朋友当作服务端，那么大概就是这个样子： 三次握手： 女朋友向程序员提出约会(Seq &#x3D; x)的建议，然后女朋友进入SYN_SEND状态。 程序员收到后同意了去约会(ACK &#x3D; x + 1), 然后向女朋友建议去吃麻辣烫吧(Seq &#x3D; y)，程序员进入SYN_RCVD状态。 女朋友收到建议后，勉为其难的答应了，然后告诉程序员说 那好吧(ACK &#x3D; y + 1)。女朋友就进入了ESTABLISHED状态， 程序员也进入了 ESTABLISHED状态，整个约会讨论结束。 四次挥手： 女朋友向程序员提出分手 程序员告诉女朋友说，我知道了，但是要考虑一下 程序员考虑清楚后，跟女朋友说那就分手吧 女朋友接收到程序员的消息后，然后还在等程序员发挽留的消息，然而等了两天后没等到，就认为程序员是真的不会再发消息来了，于是就拉黑删除程序员，关闭连接了。 HTTP的版本特点： HTTP&#x2F;0.9：无状态、只有GET HTTP&#x2F;1.0：支持POST、增加头信息、增加二进制文件 HTTP&#x2F;1.1：Keep-Alive、管线化 HTTP&#x2F;2.0：多路复用、服务器推送 ③ HTTPS的简介当网络变得越来越普遍的时候，安全性就越来越重要，这时候HTTPS就出现了。HTTPS经由HTTP进行通信，但利用SSL&#x2F;TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。 HTTPS的大致通信流程： 客户端发起一个http请求，连接到服务器的443端口 服务端把自己的信息以数字证书的形式返回给客户端 浏览器验证证书的合法性 生成随机密码（对称加密） 用服务器公钥加密后发送给服务器 ④ 服务器硬件更加可靠的能被其他终端访问的终端，管理资源并为用户提供服务，常见系统类型： GNU&#x2F;Linux(Debian、RedHat、Arch) Windows Server MacOS Server (2) 用户的内网IP怎么和公网IP进行通信？当用户越来越多，多个用户可能在同一个局域网内，走同一个网络出口访问服务器。 这时候，用户设备使用的是内网IP，这时候他们如何和公网IP就行通信呢？ 这就需要用到下面讲到的NAT技术。 2. NAT 用户的请求会在路由器中通过NAT技术转换为公网请求，发送给服务器。这里也会有两个问题： NAT是什么？ 我们常用的是URL，怎么和IP关联起来？ (1) NAT是什么？ NAT（Network Address Translation），是指网络地址转换，NAT是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术，旨在通过将一个外部 IP 地址和端口映射到更大的内部 IP 地址集来转换 IP 地址。 基本上，NAT 使用流量表将流量从一个外部（主机）IP 地址和端口号路由到与网络上的终结点关联的正确内部 IP 地址。 常见的NAT实现方式： 静态NAT(一对一) 动态NAT(多对多) NAT重载(PAT端口地址转换) (2) 我们常用的是URL，怎么和IP关联起来？想要了解URL和IP的关联，首先先得了解下URI、URL、URN： URN (Uniform Resource Name, 统一资源名称)： Ryan Shang ISBN 0-486-27557-4 URL (Uniform Resource Locator,统一资源定位符)： file:&#x2F;&#x2F;&#x2F;home&#x2F;username&#x2F;RomeoAndJuliet.pdf Tel: &#x2F;&#x2F;13800138000 URI (Uniform Resource Identifier, 统一资源标识符) 为了不让用户记住无规则的IP地址，让用户能使用URL来访问网站，出现了DNS服务来解决这个问题。 3. DNS 我们继续带着两个问题来学习： DNS是什么？ 现阶段如何提高服务稳定性？ (1) DNS是什么？ 域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。 (2) 现阶段如何提高服务稳定性？当前阶段最简单有效的就是对功能进行拆分。 4. 服务器功能拆分 我们继续带着两个问题来学习： 数据库是什么？ 现阶段如何提高服务的QPS？ (1) 数据库是什么？ 数据库，简而言之就是存放数据的地方，用户可以对这些数据执行增删改查等操作。 常见的数据库类型有关系型数据库(SQL)和非关系型数据库(NoSQL)。 关系型(SQL)： Oracle MySQL SQL Server Access PostgreSQL OceanBase 非关系型(NoSQL)： 键值存储: Redis 列存储: HBase 面向文档: MongoDB 图形: Neo4J 搜索引擎: Solr (2) 现阶段如何提高服务的QPS？这个时候想要提高服务的QPS就要用到缓存机制了 5. 缓存 我们继续带着两个问题来学习： 常见的缓存方式？ 现阶段如何提高服务的QPS？ (1) 常见的缓存方式① Redis Redis（Remote Dictionary Server）是一个使用ANSI C编写的开源、支持网络、基于内存、分布式、可选持久性的键值对存储数据库。一般情况下，MySQL的单机QPS在几千左右，而Redis的单个实例的QPS可以达到10W左右。 在一些业务场景下合理使用Redis可以大幅提高QPS。 这里再提下常见的Redis缓存问题： 缓存穿透(数据库和缓存中的无效查找) 缓存击穿(高并发请求同一个key刚好失效) 缓存雪崩(大规模缓存失效) ② 浏览器缓存浏览器也有自己的缓存机制，主要分为强缓存和协商缓存： 强缓存(Expires、Cache-Control)：不到过期时间都直接使用缓存资源。 协商缓存(Last-Modified &amp; If-Modified-Since、Etag &amp; If-None-Match)，请求服务器获取资源上次更新时间，如果有更新则重新请求，如果没有更新则直接使用缓存资源。 (2) 现阶段如何提高服务的QPS？这个阶段就可以考虑增加负载均衡机制，使用服务器集群。 6. 负载均衡 我们继续带着三个问题来学习： 什么是负载均衡？ 正向代理和反向代理是什么？ 现阶段如何提高服务的QPS？ (1) 什么是负载均衡？ 负载平衡（英语：load balancing）是一种电子计算机技术，用来在多个计算机（计算机集群）、网络连接、CPU、磁盘驱动器或其他资源中分配负载，以达到优化资源使用、最大化吞吐率、最小化响应时间、同时避免过载的目的。 负载均衡优势：解决高并发，实现高可用，提供扩展性，提高安全性 常见的负载均衡的算法： 轮询 优点：服务器请求数目相同； 缺点：服务器压力不一样，不适合服务器配置不同的情况； 随机 优点：使用简单； 缺点：不适合机器配置不同的场景； 最少链接 优点：根据服务器当前的请求处理情况，动态分配； 缺点：算法实现相对复杂，需要监控服务器请求连接数； 源地址散列 优点：将来自同一IP地址的请求，同一会话期内，转发到相同的服务器；实现会话粘滞。 缺点：目标服务器宕机后，会话会丢失； 加权，在轮询，随机，最少链接，Hash’等算法的基础上，通过加权的方式，进行负载服务器分配。 优点：根据权重，调节转发服务器的请求数目； 缺点：使用相对复杂； 常见的负载均衡方案： DNS负载均衡 IP负载均衡 链路层负载均衡 混合型负载均衡 负载均衡的方案，一定要有健康检测和双机热备，一旦负载均衡的服务挂掉，会导致所有服务不可用。 (2) 正向代理和反向代理是什么？ 正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。 反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等，反向代理是负载均衡常见的一种手段。 (3) 现阶段如何提高服务的QPS？这个阶段，就可以考虑使用分布式集群来提高服务的QPS。 7. 分布式 我们继续带着两个问题来学习： 什么是分布式？ 现阶段如何提高项目可维护性？ (1) 什么是分布式？分布式系统是计算机程序的集合，这些程序利用跨多个独立计算节点的计算资源来实现共同的目标。它也被称为分布式计算或分布式数据库，并依靠不同的节点通过公共网络进行通信和同步。这些节点通常代表独立的物理硬件设备，但也可代表单独的软件进程或其他递归封装的系统。分布式系统旨在消除系统的瓶颈或中心故障点。 分布式计算系统具有如下特点： 资源共享 — 分布式系统可以共享硬件、软件或数据 并行处理 — 多台机器可以同时处理同一功能 支持扩展 — 当扩充到其他计算机时，计算和处理能力可以按需进行扩展 错误检测 — 可以更轻松地检测故障 公开透明 — 节点可以访问系统中的其他节点并与之通信 说到分布式系统就不得不提一下CAP原则。CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。 一致性 (Consistence): 等同于所有节点访问同一份最新的数据副本 (强一致性) 可用性 (Availability): 每次请求都能获取到非错的响应，但是不保证获取的数据为最新数据 分区容错性 (Partition tolerance): 系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，此时必须在 C 和 A 之间做出取舍 (2) 现阶段如何提高项目可维护性？上面的更多的是讲技术层面的提升，现阶段想提升项目可维护性，就该进入一个新的阶段——业务拆分 8. 业务拆分 业务拆分简单来说就是把业务划分为一个个独立的业务模块，通过远程调用和消息队列等实现不同业务间的通信，通过Docker容器化技术更简单高效的实现业务的划分。 我们继续带着四个问题来学习： 远程调用是什么？ 消息队列是什么？ Docker是什么？ 现阶段如何提高项目可维护性？ (1) 远程调用是什么？ 分布式计算中，远程过程调用（英语：Remote Procedure Call，RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一个地址空间（通常为一个开放网络的一台计算机）的子程序，而程序员就像调用本地程序一样，无需额外地为这个交互作用编程（无需关注细节）。RPC是一种服务器-客户端（Client&#x2F;Server）模式，经典实现是一个通过发送请求-接受回应进行信息交互的系统。 远程过程调用RPC需要解决的问题： Call ID映射 序列化和反序列化 网络传输 远程过程调用RPC和Restful Api的区别：RPC VS Restful &#x3D;&gt; 面向过程 VS 面向资源 (2) 消息队列是什么？ 在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的资料，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。 消息队列的优势： 削峰填谷 降低耦合 消息队列的劣势： 系统可用性降低 系统复杂度提高 需要考虑一致性问题 发布-订阅模式是消息队列中常用的一种模式。 (3) Docker是什么？ Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 Docker的优势： 多环境切换 持续集成 复杂换件一键构建 项目隔离 (4) 现阶段如何提高项目可维护性？身为前端，怎么能忘了前后端分离这件事。 9. 前后端分离 前后端分离前端开发就比较熟悉了，静态资源和动态请求分别放在不同的服务器上，可以进一步实现功能上的分离。 这个时候的问题： 现阶段如何提高不同地区用户访问速度？ (1) 现阶段如何提高不同地区用户访问速度涉及到不通过地区，那就该CDN登场了。 10. CDN 最后的问题： 什么是CDN？ (1) 什么是CDN？ CDN(Content Delivery Network)，内容分发网络。 简单理解，就类似于京东的仓储物流，对于不同地区的用户就近建立仓库，按照用户的地理位置，就近选择仓库发货。 CDN的DNS请求的过程： 输入URL 本地DNS解析 CNAME到CDN专用DNS服务器 CDN的全局负载均衡 CDN的区域负载均衡 最优的缓存服务器节点 IP地址返回给用户 三、浏览器渲染以一个URL的旅途，说完了现代Web服务架构的演进，最后一环，就是获取资源之后浏览器页面的渲染，这里就贴一张图来展示浏览器的渲染过程，不再赘述。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小知识","slug":"小知识","permalink":"https://www.ryanshang.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.ryanshang.com/tags/HTTPS/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.ryanshang.com/tags/HTTP/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.ryanshang.com/tags/Nginx/"}]},{"title":"移动端iOS支付测试方法","slug":"移动端iOS支付测试方法","date":"2020-09-18T16:00:00.000Z","updated":"2024-01-07T11:58:50.332Z","comments":true,"path":"2020/09/19/移动端iOS支付测试方法/","link":"","permalink":"https://www.ryanshang.com/2020/09/19/%E7%A7%BB%E5%8A%A8%E7%AB%AFiOS%E6%94%AF%E4%BB%98%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/","excerpt":"背景在商业产品的业务中，会有接入iOS支付的需求，但是iOS支付接入，会有这三个点： 需要配置host访问业务的沙箱环境 中间需要接口请求访问苹果相关服务 苹果服务会有SSL Pinning导致这些接口走代理服务会被iOS拦截 这就导致一个问题，手机配置host需要使用charles走代理，但是苹果相关接口会因此无法访问，陷入僵局 方案","text":"背景在商业产品的业务中，会有接入iOS支付的需求，但是iOS支付接入，会有这三个点： 需要配置host访问业务的沙箱环境 中间需要接口请求访问苹果相关服务 苹果服务会有SSL Pinning导致这些接口走代理服务会被iOS拦截 这就导致一个问题，手机配置host需要使用charles走代理，但是苹果相关接口会因此无法访问，陷入僵局 方案既然无法在抓包时处理这种情况，就想到使用设备的自动代理，同过js脚本进行分流，让特定域名不走代理即可。 使用手机的代理时，配置wifi网络的代理为自动，并填写一个url，指向一个代理js文件，js文件内容如下： 12345678910function FindProxyForURL(url, host) &#123; if ( shExpMatch(host, &quot;*.apple.com&quot;) || shExpMatch(host, &quot;*.itunes.apple.com&quot;) || shExpMatch(host, &quot;*.mzstatic.com&quot;) ) &#123; return &quot;DIRECT&quot;; &#125; return &quot;PROXY xx.xx.xx.xx:8888; DIRECT;&quot;;&#125; 大致意思是匹配域名，如果是苹果相关的几个域名，走直连，其他的走代理，PROXY xx.xx.xx.xx:8888中的IP和端口就是代理服务器的IP和端口。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.ryanshang.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"代理","slug":"代理","permalink":"https://www.ryanshang.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"iOS","slug":"iOS","permalink":"https://www.ryanshang.com/tags/iOS/"}]},{"title":"Node后台开发中使用TypeOrm遇到的问题","slug":"Node后台开发中使用TypeOrm遇到的问题","date":"2020-01-16T16:00:00.000Z","updated":"2020-02-08T10:34:21.098Z","comments":true,"path":"2020/01/17/Node后台开发中使用TypeOrm遇到的问题/","link":"","permalink":"https://www.ryanshang.com/2020/01/17/Node%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BD%BF%E7%94%A8TypeOrm%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"前言最近项目中使用Node开发，Nest.js作为框架，TypeOrm连接数据库，期间遇到一些坑，这里记录一下。 问题1. 插入数据之后返回的ID集合，ID相同在TypeOrm插入数据库操作的返回结果中，identifiers字段会是插入数据的id集合，预期情况应该是这样的：","text":"前言最近项目中使用Node开发，Nest.js作为框架，TypeOrm连接数据库，期间遇到一些坑，这里记录一下。 问题1. 插入数据之后返回的ID集合，ID相同在TypeOrm插入数据库操作的返回结果中，identifiers字段会是插入数据的id集合，预期情况应该是这样的： 1234[ &#123; id: 1 &#125;, &#123; id: 2 &#125;] 但实际开发中发现是这样： 1234[ &#123; id: 1 &#125;, &#123; id: 1 &#125;] 因为，业务中后面要根据返回的ID值给其他数据做关联，所以返回相同ID会造成异常。 查看了github，有相关issue，但是一直处于open状态：https://github.com/typeorm/typeorm/issues/2131。 最后临时方案是采用在后面操作中，用id+数组index的方式，拼出id。 2. JavaScript对数据库中int和bigint的区别对待刚开始开发中，线下测试数据库id字段采用int，数据库SELECT操作返回的结果是Number，但是使用bigint，数据库返回的为String，初步猜想是因为bigint的值范围会超过Number，所以采用String。 但是这样会对我们业务产生巨大影戏那个，一方面，DTO校验会无法通过，另一方面，问题1中的业务逻辑会受影响。 经过查找各方文档，解决方案是在数据库连接配置中配置： 1&quot;supportBigNumbers&quot;: false 可以配置这个的原因是我们的业务ID距离Number的上线远远达不到，所以可以用这种方式让 bigint也返回Number。 但是这样配置，TypeOrm插入操作的返回值中的identifiers字段中的id还是String，所以问题1中的处理方式也要对String进行parseInt操作。 3. 数据库版本区别问题测试上线时，发现功能无法使用，测试环境正常，经过线上测试库分别连接测试定位后，发现还是identifiers，返回的id为undefined。 线上数据库版本为5.6，测试数据库版本为5.7。TypeOrm的insert()生成的SQL会有插入id的操作，值为默认值，5.7中可以正常插入，5.6中会插入异常，返回值为undefined，导致报错异常事务回滚。 经过测试，插入数据库操作时，id赋值为null可以解决，后更新上线，因为部署问题无法上线，等待后续上线后检验时候还存在问题。 4. TypeOrm数据库配置问题导致编译慢项目刚开始开发时，每次本地编辑十分慢，查找文档等发现问题是配置原因，刚开始数据库的entities配置项是这样的： 1&quot;entities&quot;: [&quot;src/entities/*.ts&quot;] 编译时候应该是先会把ts文件编译成js，所以耗时比较久，后改成 1&quot;entities&quot;: [&quot;output/nodeapp/kid-mis-backend/src/entities/*.js&quot;] 直接使用编译后的js文件，编译速度大大提升。 总结后端开发和前端开发有很大的区别，各种解决问题思路不同，后端部分还有很多需要我学习的地方。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.ryanshang.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://www.ryanshang.com/tags/Node/"},{"name":"TypeOrm","slug":"TypeOrm","permalink":"https://www.ryanshang.com/tags/TypeOrm/"}]},{"title":"个人终端环境配置（zsh）","slug":"个人终端环境配置（zsh）","date":"2020-01-04T16:00:00.000Z","updated":"2024-01-05T22:48:06.141Z","comments":true,"path":"2020/01/05/个人终端环境配置（zsh）/","link":"","permalink":"https://www.ryanshang.com/2020/01/05/%E4%B8%AA%E4%BA%BA%E7%BB%88%E7%AB%AF%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88zsh%EF%BC%89/","excerpt":"个人使用的开发Mac，很早就用别人给的教程配置好了Zsh，使用一直很舒服，这次在自己的deepin上配置一次，这里做个简单记录。 安装清单 名称 备注 链接 zsh shell的一种 https://www.zsh.org/ oh-my-zsh zsh的配置工具 https://ohmyz.sh/ zsh-autosuggestions 命令自动补全插件 https://github.com/zsh-users/zsh-autosuggestions zsh-syntax-highlighting 命令高亮插件 https://github.com/zsh-users/zsh-syntax-highlighting Powerline 个人用主题的字体（不用会乱码） https://github.com/powerline/fonts iTerm2 Mac下一个推荐的终端 http://iterm2.com/ 安装过程1. 安装zsh","text":"个人使用的开发Mac，很早就用别人给的教程配置好了Zsh，使用一直很舒服，这次在自己的deepin上配置一次，这里做个简单记录。 安装清单 名称 备注 链接 zsh shell的一种 https://www.zsh.org/ oh-my-zsh zsh的配置工具 https://ohmyz.sh/ zsh-autosuggestions 命令自动补全插件 https://github.com/zsh-users/zsh-autosuggestions zsh-syntax-highlighting 命令高亮插件 https://github.com/zsh-users/zsh-syntax-highlighting Powerline 个人用主题的字体（不用会乱码） https://github.com/powerline/fonts iTerm2 Mac下一个推荐的终端 http://iterm2.com/ 安装过程1. 安装zsh各家平台的包管理工具都可以安装。 2. 安装oh-my-zsh1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; 推荐使用curl方式，会修改shell默认为zsh。 3. 修改配置编辑.zshrc，找到主题，修改为： 1ZSH_THEME=&quot;agnoster&quot; 重启终端，会更换主题。更换后会发现有部分乱码。 4. 解决字体乱码问题安装powerline： 12345678# clonegit clone https://github.com/powerline/fonts.git --depth=1# installcd fonts./install.sh# clean-up a bitcd ..rm -rf fonts 配置字体为：Meslo LG M for Powerline 卸载执行: 1./uninstall.sh 5. 安装插件12git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestionsgit clone https://github.com/zsh-users/zsh-syntax-highlighting $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting 安装完成后，修改.zshrc 12345plugins=( zsh-autosuggestions zsh-syntax-highlighting git) 重启终端。 6. 其他Mac上的配色方案可以用solarized 1234567891011121314151617# git下Solarized 的源码git clone git://github.com/altercation/solarized.git# 进入文件夹cd solarized/vim-colors-solarized/colors#下面可能要管理员权限sudo mkdir -p ~/.vim/colorssudo cp solarized.vim ~/.vim/colors/# 创建.vimrc文件sudo vim ~/.vimrc# 把下面这三行复制进去syntax enableset background=darkcolorscheme solarized","categories":[{"name":"工具","slug":"工具","permalink":"https://www.ryanshang.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"Zsh","slug":"Zsh","permalink":"https://www.ryanshang.com/tags/Zsh/"}]},{"title":"记录一次个人git事故","slug":"记录一次个人git事故","date":"2019-12-24T16:00:00.000Z","updated":"2020-03-18T02:24:04.082Z","comments":true,"path":"2019/12/25/记录一次个人git事故/","link":"","permalink":"https://www.ryanshang.com/2019/12/25/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E4%B8%AA%E4%BA%BAgit%E4%BA%8B%E6%95%85/","excerpt":"今天圣诞节，在工作时侯，出现了一个有意思的意外情况，这里做下记录。 事情经过一个比较大的需求，每天都保持了一次个人开发分支提交。今天发现有4次提交没有合并到主开发分支，于是动手合并，合并记如下： 123456789101112131410262 gco dev10263 git pull10264 git log10265 gco feature/my-dev-branch10266 git rebase dev10267 git rebase -i HEAD~410268 git log10269 git rebase -i HEAD~110270 git log10271 git push -f10272 gco dev10273 git merge feature/my-dev-branch10274 git push10275 git log 我们部门合并到主开发分支前，要求合并下commit记录，按照以往的流程是没有问题的。","text":"今天圣诞节，在工作时侯，出现了一个有意思的意外情况，这里做下记录。 事情经过一个比较大的需求，每天都保持了一次个人开发分支提交。今天发现有4次提交没有合并到主开发分支，于是动手合并，合并记如下： 123456789101112131410262 gco dev10263 git pull10264 git log10265 gco feature/my-dev-branch10266 git rebase dev10267 git rebase -i HEAD~410268 git log10269 git rebase -i HEAD~110270 git log10271 git push -f10272 gco dev10273 git merge feature/my-dev-branch10274 git push10275 git log 我们部门合并到主开发分支前，要求合并下commit记录，按照以往的流程是没有问题的。 但是在执行git rebase -i HEAD~4合并commit记录时候，可能最近用vim写文件删除操作较多，顺手把三个记录直接使用vim快捷操作dd删除并快速保存，并不是修改提交记录前的标签。当时并没有注意，执行git push -f后，发现VSCode中打开的文件显示已删除，于是才发现问题。 事情后果如果不处理，相当于三天工作量打水漂，代码需要重写，严重影响排期。 解决过程第一反应是执行git log查看已经提交的记录是否存在，存在的话使用git reset配合记录的哈希值可以恢复到那次提交记录。结果当然相关的 commit 记录已经被删除。 如果可以找到丢失的commit记录，应该就可以快速找回丢失的代码。 于是去git官网和搜索引擎下找了commit记录丢失后的相关命令，发现这个命令： 1git reflog 返回结果里面包含本队分支的操作记录，包括提交、切换分支等，在其中找到对应提交的哈希值，使用git reset命令成功回到最新一次提交，找回所有代码。 事后反思 对git操作一定要谨慎 每做一步操作，及时检查，不能认为自己经常操作的步骤就一定没有问题 多了解git的命令，有助于出错后及时拨乱反正","categories":[{"name":"工具","slug":"工具","permalink":"https://www.ryanshang.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.ryanshang.com/tags/Git/"}]},{"title":"Linux任务脚本","slug":"Linux任务脚本","date":"2019-12-21T16:00:00.000Z","updated":"2020-02-08T10:34:21.089Z","comments":true,"path":"2019/12/22/Linux任务脚本/","link":"","permalink":"https://www.ryanshang.com/2019/12/22/Linux%E4%BB%BB%E5%8A%A1%E8%84%9A%E6%9C%AC/","excerpt":"这几周在研究安卓手机的Linux Deploy和FRP内网穿透，每次启动关闭重启都要手动执行一些命令，于是想到用shell脚本去控制，稍稍研究了下，写了几个脚本，这里做下记录，以Frpc进程为例，假设Frp编译后的文件夹路径为/home/user/frp start.sh 1234567891011NAME=frpcNAME_OUT=&quot;$&#123;NAME^&#125;&quot;DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;&#x27;print $1&#x27;&#125;)if [[ $PID == &quot;&quot; ]]then nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo &quot;Start $NAME_OUT Success&quot;else echo &quot;$NAME_OUT is already running!&quot;fi stop.sh 1234567891011NAME=frpcNAME_OUT=&quot;$&#123;NAME^&#125;&quot;DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;&#x27;print $1&#x27;&#125;)if [[ $PID == &quot;&quot; ]]then echo &quot;$NAME_OUT is not running!&quot;else sudo kill -9 $PID echo &quot;Stop $NAME_OUT Success!&quot;fi","text":"这几周在研究安卓手机的Linux Deploy和FRP内网穿透，每次启动关闭重启都要手动执行一些命令，于是想到用shell脚本去控制，稍稍研究了下，写了几个脚本，这里做下记录，以Frpc进程为例，假设Frp编译后的文件夹路径为/home/user/frp start.sh 1234567891011NAME=frpcNAME_OUT=&quot;$&#123;NAME^&#125;&quot;DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;&#x27;print $1&#x27;&#125;)if [[ $PID == &quot;&quot; ]]then nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo &quot;Start $NAME_OUT Success&quot;else echo &quot;$NAME_OUT is already running!&quot;fi stop.sh 1234567891011NAME=frpcNAME_OUT=&quot;$&#123;NAME^&#125;&quot;DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;&#x27;print $1&#x27;&#125;)if [[ $PID == &quot;&quot; ]]then echo &quot;$NAME_OUT is not running!&quot;else sudo kill -9 $PID echo &quot;Stop $NAME_OUT Success!&quot;fi restart.sh 12345678910111213NAME=frpcNAME_OUT=&quot;$&#123;NAME^&#125;&quot;DIR=/home/user/frpPID=$(ps -e | grep $NAME | awk &#123;&#x27;print $1&#x27;&#125;)if [[ $PID == &quot;&quot; ]]then nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo &quot;Start $NAME_OUT Success!&quot;else sudo kill -9 $PID nohup $DIR/$NAME -c $DIR/$NAME.ini &gt; $DIR/nohup.out 2&gt;&amp;1 &amp; echo &quot;Restart $NAME_OUT Success!&quot;fi 现在还有几个问题需要后面关注下： awk后面参数，如果是双引号，则会又问题，单引号和双引号应该是有区别的，需要关注下有区别的原因 三个脚本其实包含大量重复内容，后面考虑合成一个脚本，利用参数方式区分执行命令 需要了解下Linux中比较常见的几个服务管理工具，了解下原理，例如service command","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.ryanshang.com/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.ryanshang.com/tags/CentOS/"}]},{"title":"个人电脑设备常用软件整理","slug":"个人电脑设备常用软件整理","date":"2019-12-14T16:00:00.000Z","updated":"2021-01-22T13:29:49.610Z","comments":true,"path":"2019/12/15/个人电脑设备常用软件整理/","link":"","permalink":"https://www.ryanshang.com/2019/12/15/%E4%B8%AA%E4%BA%BA%E7%94%B5%E8%84%91%E8%AE%BE%E5%A4%87%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%95%B4%E7%90%86/","excerpt":"整理记录下个人常用的各平台的应用软件： 1. 日常工具类 名称 备注 网址 Windows Mac Linux Motrix 下载工具 https://motrix.app/zh-CN/ ✔ ✔ ✔ Xmind 思维导图 https://www.xmind.net/ ✔ ✔ ✔ draw.io 流程图工具 https://www.draw.io/ ✔ ✔ ✔ Gas Mask host管理工具 https://github.com/2ndalpha/gasmask ✔ New File Menu Free 新建文件工具 App Store ✔ Go2Shell 在访达当前路径打开终端 https://zipzapmac.com/Go2Shell ✔ Hyper 终端 https://hyper.is/ ✔ ✔ ✔ oh-my-zsh 终端配置工具 https://ohmyz.sh/ ✔ ✔ Windows Terminal 终端 https://github.com/microsoft/terminal ✔ Listary 快捷启动工具 https://www.listary.com/ ✔ Alfred 快捷键效率工具 https://www.alfredapp.com/ ✔ Typora Markdown编辑器 https://www.typora.io/ ✔ ✔ ✔ 2. 影音娱乐类 名称 备注 网址 Windows Mac Linux listen1 吃饭工具0.0 https://listen1.github.io/listen1/ ✔ ✔ ✔ HandBrake 视频转码编辑软件 https://handbrake.fr/ ✔ ✔ ✔ Potplayer 视频播放器 https://potplayer.daum.net/ ✔ IINA 视频播放器 https://iina.io/ ✔ VLC Media Player 视频播放器 https://www.videolan.org/vlc/index.zh.html ✔ ✔ ✔","text":"整理记录下个人常用的各平台的应用软件： 1. 日常工具类 名称 备注 网址 Windows Mac Linux Motrix 下载工具 https://motrix.app/zh-CN/ ✔ ✔ ✔ Xmind 思维导图 https://www.xmind.net/ ✔ ✔ ✔ draw.io 流程图工具 https://www.draw.io/ ✔ ✔ ✔ Gas Mask host管理工具 https://github.com/2ndalpha/gasmask ✔ New File Menu Free 新建文件工具 App Store ✔ Go2Shell 在访达当前路径打开终端 https://zipzapmac.com/Go2Shell ✔ Hyper 终端 https://hyper.is/ ✔ ✔ ✔ oh-my-zsh 终端配置工具 https://ohmyz.sh/ ✔ ✔ Windows Terminal 终端 https://github.com/microsoft/terminal ✔ Listary 快捷启动工具 https://www.listary.com/ ✔ Alfred 快捷键效率工具 https://www.alfredapp.com/ ✔ Typora Markdown编辑器 https://www.typora.io/ ✔ ✔ ✔ 2. 影音娱乐类 名称 备注 网址 Windows Mac Linux listen1 吃饭工具0.0 https://listen1.github.io/listen1/ ✔ ✔ ✔ HandBrake 视频转码编辑软件 https://handbrake.fr/ ✔ ✔ ✔ Potplayer 视频播放器 https://potplayer.daum.net/ ✔ IINA 视频播放器 https://iina.io/ ✔ VLC Media Player 视频播放器 https://www.videolan.org/vlc/index.zh.html ✔ ✔ ✔ 3. 编程开发类 名称 备注 网址 Windows Mac Linux VSCode 吃饭工具0.0 https://code.visualstudio.com/ ✔ ✔ ✔ Chrome Google旗下浏览器 https://www.google.com/intl/zh-CN/chrome/ ✔ ✔ ✔ Edge 微软旗下浏览器 https://www.microsoft.com/en-us/edge ✔ ✔ Postman 请求调试软件 https://www.getpostman.com/ ✔ ✔ ✔ WSL2 Windows下Linux子系统 https://docs.microsoft.com/en-us/windows/wsl/wsl2-install ✔","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"},{"name":"工具","slug":"工具","permalink":"https://www.ryanshang.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Mac","slug":"Mac","permalink":"https://www.ryanshang.com/categories/Mac/"},{"name":"Windows","slug":"Windows","permalink":"https://www.ryanshang.com/categories/Windows/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.ryanshang.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"写在五一节后的一些思考","slug":"写在五一节后的一些思考","date":"2019-05-06T16:00:00.000Z","updated":"2019-05-07T03:29:29.744Z","comments":true,"path":"2019/05/07/写在五一节后的一些思考/","link":"","permalink":"https://www.ryanshang.com/2019/05/07/%E5%86%99%E5%9C%A8%E4%BA%94%E4%B8%80%E8%8A%82%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/","excerpt":"突然之间，就想写点东西。 有人问过我，为什么选择北漂？ 当时自己嘴上的回答很简单：自己的行业在西安找一份高工资的工作不容易，尤其是自己还处于处起步阶段，是个前端界的小学生。 其实，说心里话，当时自己心里也没有答案。 这么一两年过去了，可能心里面也有了答案。","text":"突然之间，就想写点东西。 有人问过我，为什么选择北漂？ 当时自己嘴上的回答很简单：自己的行业在西安找一份高工资的工作不容易，尤其是自己还处于处起步阶段，是个前端界的小学生。 其实，说心里话，当时自己心里也没有答案。 这么一两年过去了，可能心里面也有了答案。 一方面，我不想成为一个异类，帝都虽苦，可是不论是早上7点上班还是晚上10点下班，总有大堆大堆的人一起，虽然在外人看会像行尸走肉一样，但是每天真真切切能感受到自己的付出是有价值的，不只体现在收入上，还有个人成长和社会价值上。这样才让我有活着的感觉。 另一方面，生活在更大的城市，就意味着可以见到更广阔的世界、学到更多的东西，去不断完善我的三观。我不想做井底之蛙，这个世界我需要学习的地方还有很多。假如有一天我真的能饱览井底甚至是井上的风光，真不是井底之蛙了，我也依旧会心存一点谦恭。 这两个原因就足以支撑我北漂。虽然前路坎坷，但还有希望。世界就是这样，年轻的时候难免颠沛流离。 我是幸运的，可以做自己喜欢的事业，有自己喜欢的人。 热爱前端，但是确实发现这两年自己的成长还是太慢了。我觉得，一个人的知识面是一个圆圈，知识储备越多，圆圈越大，接触到的面积便越广阔，便能掌握和窥视更多的机会。现在的我的知识面圈子还是不够大，我还是需要更多的努力才能拥有更多的机会。我有自己的理想，但是理想越远大，也就说明我完成它需要更多的努力。 现在感觉，社会整体是浮躁的，当局者迷，我也不能置身事外。这个社会不缺脑袋灵光的人，可缺持之以恒做傻事地聪明人。我不求做一个持之以恒做傻事的聪明人，我只想成为一个可以持之以恒的普通人，为了实现自己的理想一步一个脚印。 希望自己记住自己的目标： 工作方面，开源一个东西，由前端慢慢向全栈过渡。 生活方面，保持现在良好的作息，多运动，保证身体健康。 思想方面，尽可能在生活之余多读几本好书。 人生方面，希望自己在人生的终点，不后悔现在做出的每一个选择。 看似很简单，路还很远。 思绪挺乱，随手记下来，只为了自勉。 希望我自己记住，人最重要的是有一个上升的态势，不要因为外界干扰了自己。 三十年众生马牛，六十年诸佛龙象。","categories":[{"name":"心情","slug":"心情","permalink":"https://www.ryanshang.com/categories/%E5%BF%83%E6%83%85/"}],"tags":[{"name":"心情","slug":"心情","permalink":"https://www.ryanshang.com/tags/%E5%BF%83%E6%83%85/"}]},{"title":"两道有意思的面试题","slug":"两道有意思的面试题","date":"2019-05-01T16:00:00.000Z","updated":"2020-03-18T02:23:35.875Z","comments":true,"path":"2019/05/02/两道有意思的面试题/","link":"","permalink":"https://www.ryanshang.com/2019/05/02/%E4%B8%A4%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"在面试中遇到了这么两道题，当时没有做出来，挺有意思，记录下来。 一、数组中找出项的组合1从一个数组中找出几个项和为M的所有可能。 当时乍一看想到把所有情况枚举一边，但是仔细看不知道怎么下手，回来仔细想了下，确定了个思路，可以把每一个组合转化成二进制，比如[1, 2, 3, 4]中数组第一项和第三项的组合就可以用1010表示，这样就可以快速列出所有组合的情况，然后算出对应项的和，等于M的就返回。 这个思路需要解决这么几个问题：","text":"在面试中遇到了这么两道题，当时没有做出来，挺有意思，记录下来。 一、数组中找出项的组合1从一个数组中找出几个项和为M的所有可能。 当时乍一看想到把所有情况枚举一边，但是仔细看不知道怎么下手，回来仔细想了下，确定了个思路，可以把每一个组合转化成二进制，比如[1, 2, 3, 4]中数组第一项和第三项的组合就可以用1010表示，这样就可以快速列出所有组合的情况，然后算出对应项的和，等于M的就返回。 这个思路需要解决这么几个问题： 如何把所有的组合罗列出来进行遍历？ 如何根据二进制的表示计算出这个组合中项的和？ 如果，规定组合只能有几项，而不是要求所有情况该怎么处理？ 我们来一个一个看。 首先，如何把所有组合罗列出来进行遍历？ 既然决定采用二进制表示，那么最简单的方式实际上就是累加。 例如，[1, 2, 3, 4]组合有16种： 12340000、0001、0010、0011、0100、0101、0110、0111、1000、1001、1010、1011、1100、1101、1110、1111 其实换算成10进制就是0到15，共16中情况，也就是 2的数组长度的次方Math.pow(2, arr.length)，只要一个循环累加就可以。 接着，如何根据这个二进制表示计算项的和？ 我第一时间想到的，就是把这个字符串一位一位遍历，如果字符串的项是1，则进行累加，并把对应的数组中的项记录下来。 1234567let binStr = i.toString(2);binStr.split(&#x27;&#x27;).forEach((item, index) =&gt; &#123; if (item === &#x27;1&#x27;) &#123; s += arr[index] temp.push(arr[index]) &#125;&#125;) 这里有个问题，在把一个数利用toString()转换成二进制字符串时，是不会出现0110这样的字符串，而是会出现110，需要补零。 123456789let binStr = i.toString(2);// 对二进制的字符串进行补零，保证字符串长度和数组长度一致binStr = &#x27;0&#x27;.repeat(arr.length - binStr.length) + binStr;binStr.split(&#x27;&#x27;).forEach((item, index) =&gt; &#123; if (item === &#x27;1&#x27;) &#123; s += arr[index] temp.push(arr[index]) &#125;&#125;) 最后，如果限定项数，就需要多加一层过滤，增加一个用来计数的counter来计算每个字符串的项数。 12// 获取数字转化成二进制字符串后有多少个1const counter = num =&gt; num.toString(2).replace(/0/g, &#x27;&#x27;).length; 这三个问题解决后，来看下所有代码。 12345678910111213141516171819202122232425function GetCombBySumFromArray(arr, sum, count) &#123; // 获取数字转化成二进制字符串后有多少个1 const counter = num =&gt; num.toString(2).replace(/0/g, &#x27;&#x27;).length; let len = arr.length, res = []; // 外循环：数组项随机组合的所有可能性组合 for (let i = 0; i &lt; Math.pow(2, len); i++) &#123; if (!count || counter(i) == count) &#123; let s = 0, temp = [], binStr = i.toString(2); // 对二进制的字符串进行补零，保证字符串长度和数组长度一致 binStr = &#x27;0&#x27;.repeat(arr.length - binStr.length) + binStr; // 内循环，主要作用是把在这个组合中的对应的数组的项相加，推入临时数组 binStr.split(&#x27;&#x27;).forEach((item, index) =&gt; &#123; if (item === &#x27;1&#x27;) &#123; s += arr[index] temp.push(arr[index]) &#125; &#125;) // 满足要求 if (s == sum) &#123; res.push(temp) &#125; &#125; &#125; return res;&#125; 来测试下，看下执行结果。 1console.log(GetCombBySumFromArray([-1, 3, 9, 4, 6, -4, 5, 8, 1, 7], 5, 0)); 看起来是正常的，接下来，考虑一个问题，既然已经采用二进制，是不是可以考虑用位运算？答案肯定是可以的，我本身对位运算使用不多，所以借助了下网上的资料，发现有两个地方可以优化。 原本在内循环中是通过拆字符串一项一项比较，其实可以通过位运算去判断这一项是不是在这个组合中 1234567for (let j = 0; j &lt; len; j++) &#123; // 判断当前数是否在这个组合中 if (0b0110 &amp; 1 &lt;&lt; (len - 1 - j)) &#123; s += arr[j] temp.push(arr[j]) &#125;&#125; 循环还是大同小异的循环，只不过，判断的方法变成了(0b0110 &amp; 1 &lt;&lt; (len - 1 - j))，这里才是重点，根据循环，0b0110需要依次和1000、100、10、1进行&amp;运算，这样结果不为0的就表示这项在这个组合中存在。 counter的升级，也是运用了&amp;运算 12345678const counter = num =&gt; &#123; let count = 0 while (num) &#123; num = num &amp; (num - 1) count++ &#125; return count&#125; 来看下升级过后的函数： 12345678910111213141516171819202122232425262728293031const GetCombBySumFromArray = (arr, sum, count) =&gt; &#123; // 获取数字转化成二进制字符串后有多少个1 const counter = num =&gt; &#123; let count = 0 while (num) &#123; num = num &amp; (num - 1) count++ &#125; return count &#125; let len = arr.length, res = []; // 外循环：数组项随机组合的所有可能性组合 for (let i = 0; i &lt; Math.pow(2, len); i++) &#123; if (!count || counter(i) == count) &#123; let s = 0, temp = []; // 内循环，主要作用是把在这个组合中的对应的数组的项相加，推入临时数组 for (let j = 0; j &lt; len; j++) &#123; // 判断当前数是否在这个组合中 if (i &amp; 1 &lt;&lt; (len - 1 - j)) &#123; s += arr[j] temp.push(arr[j]) &#125; &#125; // 满足要求 if (s == sum) &#123; res.push(temp) &#125; &#125; &#125; return res;&#125; 位运算还是挺有意思的，可是平时用的还是不多，导致解决问题时不一定能想起来采用位运算，有机会需要更深入了解下位运算的应用。 这个题应该还有其他解法，先放在这，等后面有功夫再想想其他解法。 二、同心圆 1这样一个同心圆，三种颜色，你用几个div可以做到？ 这个题，当时听道，第一反应就是一个，div+border+box-shadow就可以做到： 12345678910#circle &#123; margin:100px auto; width: 300px; height: 300px; border-radius: 50%; background: aqua; position: relative; border: 50px solid orange; box-shadow: 0px 0px 0px 50px yellow;&#125; 然后后面继续问道，四种颜色呢？ 这时候我第一反应是，CSS的渐变。 12345678#circle &#123; margin:100px auto; width: 300px; height: 300px; border-radius: 50%; background: repeating-radial-gradient(circle, rgb(255, 255, 255) 10%, rgb(0, 0, 0) 20%); position: relative;&#125; 渐变的我话，别说四个，更多的也可以解决。但是要求是不能使用渐变。这个时候就有点懵，面试官这时候提示道CSS的伪元素可以么，想了下，确实可以。 1234567891011121314151617181920212223242526#circle::before &#123; content: &#x27; &#x27;; position: absolute; width: 100px; height: 100px; border-radius: 50%; top: 50%; left: 50%; margin-top: -50px; margin-left: -50px; background: purple; z-index: 20;&#125;#circle::after &#123; content: &#x27; &#x27;; position: absolute; width: 200px; height: 200px; border-radius: 50%; top: 50%; left: 50%; margin-top: -100px; margin-left: -100px; background: chartreuse; z-index: 10;&#125; 问题解决。以往自己用到before和after多的还是icon或者清除浮动等，很久不接触，突然想不起来，其实伪元素的作用真的挺大，自己在CSS方面的基础真的还需要再去细细梳理下。前端还是非常有意思的。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"},{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"},{"name":"面试题","slug":"面试题","permalink":"https://www.ryanshang.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"call和bind","slug":"call和bind","date":"2019-04-29T16:00:00.000Z","updated":"2019-05-06T10:26:47.397Z","comments":true,"path":"2019/04/30/call和bind/","link":"","permalink":"https://www.ryanshang.com/2019/04/30/call%E5%92%8Cbind/","excerpt":"call、apply和bind常用来显示改变函数运行环境中的this指向，这几天突发奇想如果call.call、bind.bind和bind().band()会是怎样的结果，先记录一下，给出一下我现在认为的结论，后面有时间了，深入研究下。 公共12345678function fn01 () &#123; console.log(&#x27;fn01:&#x27;, this); &#125;function fn02 () &#123; console.log(&#x27;fn02:&#x27;, this); &#125;let obj = &#123; fn: fn01 &#125;let fn03 = obj.fn;fn01(); // fn01 windowfn02(); // fn02 windowfn03(); // fn01 windowobj.fn(); // fn01 obj 这其中定义了两个函数fn01和fn02以及一个对象，每个方法右面注释是执行主体和this指向。上面的几种是比较常见的情况。 call","text":"call、apply和bind常用来显示改变函数运行环境中的this指向，这几天突发奇想如果call.call、bind.bind和bind().band()会是怎样的结果，先记录一下，给出一下我现在认为的结论，后面有时间了，深入研究下。 公共12345678function fn01 () &#123; console.log(&#x27;fn01:&#x27;, this); &#125;function fn02 () &#123; console.log(&#x27;fn02:&#x27;, this); &#125;let obj = &#123; fn: fn01 &#125;let fn03 = obj.fn;fn01(); // fn01 windowfn02(); // fn02 windowfn03(); // fn01 windowobj.fn(); // fn01 obj 这其中定义了两个函数fn01和fn02以及一个对象，每个方法右面注释是执行主体和this指向。上面的几种是比较常见的情况。 call1234567fn01.call(fn02); // fn01 fn02fn01.call.call(fn02); // fn02 windowfn01.call.call(fn02, fn02); // fn02 fn02fn01.call.call.call(fn02); // fn02 windowfn01.call.call.call.call(fn02); // fn02 windowfn01.call.call.call.call.call(fn02); // fn02 windowfn01.call.call.call.call.call(fn02, fn02, fn02, fn02, fn02); // fn02 fn02 从这开始是主要内容，第一句，是比较常见的方式，执行fn01，this指向改为fn02。 接着就是我的疑惑的地方：call.call 从结果上看，call.call中间插入几个call并不影响最终结果。 注意看下这两句： 12fn01.call.call(fn02); // fn02 windowfn01.call.call(fn02, fn02); // fn02 fn02 按我现在的看法，fn01.call.call(fn02)可能就相当于fn02.call()。 这行代码的运行过程可能是这样：fn01.call执行了call方法，改变了fn01.call的this指向为fn02。但是fn01.call执行的this指向是fn01，所以最终执行主体就变成了fn02。这时候就相当于fn02.call()，因为call没有参数，所以结果this指向了window。 这样看，fn01.call.call(fn02, fn02)相当于fn02.call(fn02)。所以最终结果，fn02是执行主体，this也指向了fn02。 后面加多少个call，原里应该都是一样的，所以不再赘述。 bind12345678910111213141516171819202122232425// bindlet fn04 = fn01.bind();fn04(); // fn01 windowlet fn05 = fn01.bind(fn02);fn05(); // fn01 fn02let fn06 = fn01.bind(fn01).bind(fn01);fn06(); // fn01 fn01let fn07 = fn01.bind(fn01).bind(fn02);fn07(); // fn01 fn01let fn08 = fn01.bind(fn02).bind(fn01);fn08(); // fn01 fn02let fn09 = fn01.bind(fn02).bind(fn02);fn09(); // fn01 fn02let fn10 = fn01.bind(fn02).bind(fn01).bind(fn01);fn10(); // fn01 fn02let fn11 = fn01.bind(fn01).bind(fn02).bind(fn02);fn11(); // fn01 fn01let fn12 = fn01.bind(obj).bind(fn01);fn12(); // fn01 objlet fn13 = fn01.bind.bind(fn02);fn13(); // 无输出let fn14 = fn13();fn14(); // fn02 windowlet fn15 = fn13(fn01);fn15(); // fbn02 fn01 bind有两种情况一种是bind.bind，一种是bind().bind()。 首先来看bind().bind()，无论链式多少个，实际上都以第一个bind()中的参数为准，原因可能是bind函数返回的函数中的this已经被外层的bind函数（第一个bind函数）确定，后面再进行bind操作传进来的参数没有做处理。但此原因暂时没有验证，仅作猜想。 接着是bind.bind，bind.bind可能和call.call类似，fn01.bind执行了bind方法，改变了fn01.bind的this指向为fn02。但是fn01.bind执行的this指向是fn01，所以最终执行主体就变成了fn02。这时候就相当于fn02.bind()，因为bind没有参数，所以结果this指向了window。执行一次fn02.bind()（也就是fn13），返回的函数执行后，就和call.call的结论类似，只是最后一次传参的方式不太一样。 以上所有结论仅是猜想，还需要从更加深入的研究this指向还有call、bind的机制，设计出合理的验证方式。因时间原因，先放一放。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"你不知道的JavaScript","slug":"你不知道的JavaScript","date":"2019-04-17T16:00:00.000Z","updated":"2019-05-20T08:56:56.283Z","comments":true,"path":"2019/04/18/你不知道的JavaScript/","link":"","permalink":"https://www.ryanshang.com/2019/04/18/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/","excerpt":"JavaScript中总会出现很多有意思的小地方，这里会把我遇到的问题进行总结，并不定期更新。 1. 函数提升和变量提升的优先级？函数的执行一般有这么几个步骤： 开辟一个私有作用域 形参赋值 变量提升和函数提升 代码按顺序执行 其中第三步，函数声明的提升优先级要高于变量提升。","text":"JavaScript中总会出现很多有意思的小地方，这里会把我遇到的问题进行总结，并不定期更新。 1. 函数提升和变量提升的优先级？函数的执行一般有这么几个步骤： 开辟一个私有作用域 形参赋值 变量提升和函数提升 代码按顺序执行 其中第三步，函数声明的提升优先级要高于变量提升。 2. vue组件的data属性为什么是一个函数返回一个对象而不是直接一个对象？为了防止vue组件的各个实例之间相互污染各自的数据 3. 为什么0.1 + 0.2 !&#x3D;&#x3D; 0.3JavaScript精度处理采用IEEE 754标准，计算机中用二进制来存储小数，而大部分小数转成二进制之后都是无限循环的值，因此存在取舍问题，也就是精度丢失，所以会出现0.1 + 0.2 !== 0.3的情况。 检测方法应该利用Number.EPSILON：0.1 + 0.2- 0.3 &gt; Number.EPSILON。 Number.EPSILON 属性表示 1 与Number可表示的大于 1 的最小的浮点数之间的差值。 4. 为什么String、Boolean和Number的基本类型数据可以调用方法？ECMAScript提供了三个特殊的引用类型：String、Boolean和Number，被称为基本包装类型，与普通引用类型的主要区别就是对象的生存期。 实际上在基本数据类型上调用方法的过程是这样的： 创建一个基本包装类型的实例 在实例上调用指定的方法 销毁这个实例 5. 定义Object的不同方式和区别先上代码： 1234567891011121314151617181920212223242526272829var o1 = &#123;name: &#x27;o1&#x27;&#125;;var o2 = new Object(&#123;name: &#x27;o2&#x27;&#125;);var M = function () &#123; this.name = &#x27;o3&#x27;&#125;;var o3 = new M();var N = class &#123; constructor () &#123; this.name = &#x27;o4&#x27;; &#125;&#125;var o4 = new N();var P = &#123;name: &#x27;o5&#x27;&#125;;var o5 = Object.create(P);console.log(o1.constructor === Object); // trueconsole.log(o2.constructor === Object); // trueconsole.log(o3.constructor === M); // trueconsole.log(o4.constructor === N); // trueconsole.log(o5.constructor === Object); // trueconsole.log(o1.hasOwnProperty(&#x27;name&#x27;)); // trueconsole.log(o2.hasOwnProperty(&#x27;name&#x27;)); // trueconsole.log(o3.hasOwnProperty(&#x27;name&#x27;)); // trueconsole.log(o4.hasOwnProperty(&#x27;name&#x27;)); // trueconsole.log(o5.hasOwnProperty(&#x27;name&#x27;)); // false 虽然上面有五种定义方式，但是在我看来，按照返回的对象区分，应该算是三种，o1和o2是一种，o3和o4是一种，o5是一种。 第一种方式构造函数是Object，属性是自己的私有属性 第二种方式构造函数是自己的类，属性是自己的私有属性 第三种方式构造函数是Object，属性是在原型链上的共有属性 6. 深拷贝和浅拷贝的区别 浅拷贝：拷贝前后对象的基本数据不受影响，只拷贝一层，不能对对象中的子对象进行拷贝 深拷贝：对对象中的子对象进行递归拷贝，拷贝前后的两个对象互不影响","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"},{"name":"小知识","slug":"小知识","permalink":"https://www.ryanshang.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"}]},{"title":"Vue Cli 3.0相关问题总结","slug":"Vue-Cli-3-0相关问题总结","date":"2019-03-29T16:00:00.000Z","updated":"2019-04-13T10:18:08.539Z","comments":true,"path":"2019/03/30/Vue-Cli-3-0相关问题总结/","link":"","permalink":"https://www.ryanshang.com/2019/03/30/Vue-Cli-3-0%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"1. 打包出现无用htmlKA管理员平台登录页面复用KA客户平台登录页面，登录页面需要把部分js通过Webpack打包方式插入到页面中。由于管理员平台采用Vue-Cli3，Vue-Cli3中帮我们处理了需要HtmlWebpackPlugin的地方，在vue.config.js中配置page就会自动编译为HtmlWebpackPlugin的相关配置。但因为登录页面login.html中需要打包进去几个js文件，js文件如果也写在pages配置中，会导致build后多出无用的html文件。 如上图，这样打包会导致出现hover3D.html、stage.html和logincss.html几个无用文件。 解决方案是把除了index的部分注释掉，然后把login相关配置写在configureWebpack中。沿用以前的配置，配置写在entry中（不过官方貌似不推荐这么做），然后配置登录页的HtmlWebpackPlugin插件。Vue-Cli3会把configureWebpack中的内容merge到webpack的配置中去。","text":"1. 打包出现无用htmlKA管理员平台登录页面复用KA客户平台登录页面，登录页面需要把部分js通过Webpack打包方式插入到页面中。由于管理员平台采用Vue-Cli3，Vue-Cli3中帮我们处理了需要HtmlWebpackPlugin的地方，在vue.config.js中配置page就会自动编译为HtmlWebpackPlugin的相关配置。但因为登录页面login.html中需要打包进去几个js文件，js文件如果也写在pages配置中，会导致build后多出无用的html文件。 如上图，这样打包会导致出现hover3D.html、stage.html和logincss.html几个无用文件。 解决方案是把除了index的部分注释掉，然后把login相关配置写在configureWebpack中。沿用以前的配置，配置写在entry中（不过官方貌似不推荐这么做），然后配置登录页的HtmlWebpackPlugin插件。Vue-Cli3会把configureWebpack中的内容merge到webpack的配置中去。 这样打包就不会出现无用的html文件。 2. 打包部署后，js不执行，不报错。 在HtmlWebpackPlugin配置的chunks中加入’chunk-vendors’, ‘chunk-common’解决 3. static文件夹中内容打包后没有复制到dist采用阿里的iconfont，下载字体文件放在&#x2F;static&#x2F;fonts文件夹中，打包后并没有出现在&#x2F;dist&#x2F;fonts中。 VUE CLI 3中不会默认打包static中的文件，需要把文件放在&#x2F;public中。把字体文件放在**&#x2F;public&#x2F;fonts**中，字体文件成功打包到&#x2F;dist&#x2F;fonts中","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.ryanshang.com/tags/Vue/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"https://www.ryanshang.com/tags/Vue-Cli/"}]},{"title":"一个实现不清空Vuex Store的刷新页面方式","slug":"一个实现不清空Vuex-Store的刷新页面方式","date":"2019-03-15T16:00:00.000Z","updated":"2019-04-13T10:28:49.245Z","comments":true,"path":"2019/03/16/一个实现不清空Vuex-Store的刷新页面方式/","link":"","permalink":"https://www.ryanshang.com/2019/03/16/%E4%B8%80%E4%B8%AA%E5%AE%9E%E7%8E%B0%E4%B8%8D%E6%B8%85%E7%A9%BAVuex-Store%E7%9A%84%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%E6%96%B9%E5%BC%8F/","excerpt":"最近某个业务需求，需要在某个时刻更新页面数据，因为有些页面接口比较多，全部采取直接刷新页面的方式。页面刷新有两种方式，window.location.reload()和this.$router.go(0)。但是两种刷新会导致清空store，部分需要store数据支持的功能就会出现问题。为了保证store的数据，使路由变成其他再变回来可能是比较好的方式。 为了不影响其他页面，所以写了个refresh.vue的页面，专门用来刷新页面。需要刷新的时候，跳转到refresh页面。refresh.vue只有一个beforeRouteEnter的方法。 原本选用的是vue-router的push和go方法搭配，后面发现这样处理浏览器的前进按钮会启用，但是前进后无反应，比较怪异，最后选择用vue-router的replace替代，replace()方法会替换当前路由，不会对浏览器路由造成影响。","text":"最近某个业务需求，需要在某个时刻更新页面数据，因为有些页面接口比较多，全部采取直接刷新页面的方式。页面刷新有两种方式，window.location.reload()和this.$router.go(0)。但是两种刷新会导致清空store，部分需要store数据支持的功能就会出现问题。为了保证store的数据，使路由变成其他再变回来可能是比较好的方式。 为了不影响其他页面，所以写了个refresh.vue的页面，专门用来刷新页面。需要刷新的时候，跳转到refresh页面。refresh.vue只有一个beforeRouteEnter的方法。 原本选用的是vue-router的push和go方法搭配，后面发现这样处理浏览器的前进按钮会启用，但是前进后无反应，比较怪异，最后选择用vue-router的replace替代，replace()方法会替换当前路由，不会对浏览器路由造成影响。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.ryanshang.com/tags/Vue/"}]},{"title":"前端与单元测试","slug":"前端与单元测试","date":"2019-01-31T16:00:00.000Z","updated":"2019-04-15T00:14:46.024Z","comments":true,"path":"2019/02/01/前端与单元测试/","link":"","permalink":"https://www.ryanshang.com/2019/02/01/%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"本文转载自知乎@大笑，原文链接：https://zhuanlan.zhihu.com/p/55887740 先来几个专业词汇，这样显得高大上一点（不存在的&#x3D;。&#x3D;） BDD: Behavior-Driven Development (行为驱动开发)TDD: Test-Driven Development (测试驱动开发)ATDD: Acceptance Test Driven Development(验收测试驱动开发) 好，说完了，然后我们废话不多说，直接进入正题。我会从多个测试框架入手，结合各种断言库，用代码方式说明。","text":"本文转载自知乎@大笑，原文链接：https://zhuanlan.zhihu.com/p/55887740 先来几个专业词汇，这样显得高大上一点（不存在的&#x3D;。&#x3D;） BDD: Behavior-Driven Development (行为驱动开发)TDD: Test-Driven Development (测试驱动开发)ATDD: Acceptance Test Driven Development(验收测试驱动开发) 好，说完了，然后我们废话不多说，直接进入正题。我会从多个测试框架入手，结合各种断言库，用代码方式说明。 单元测试（Unit Testing），是指对软件中的最小可测试单元进行检查和验证。 当今所有著名的框架都要进行单元测试，经过测试的框架，它的信任度显然高于未测试的框架。 这里，我们介绍一下karma这个前端的单元测试框架。 Spectacular Test Runner for Javascripthttp://karma-runner.github.io/3.0/index.html 首先我们来安装一波：新建一个空文件夹，然后在空文件夹中打开终端输入 1234npm init -y(sudo) npm install karma-cli -gnpm install karma karma-jasmine karma-chrome-launcher jasmine-core --save-devnpm install karma-phantomjs-launcher --save-dev 你安装karma-cli这个倒是说得过去，可是这个jasmine是啥，这个chrome-launcher和phantomjs-launcher又是啥？ 没错，单说测试框架是不完整的，必须要有断言库与之相配合，这里的jasmine就是断言库。 啥是断言（assert）？ 根据概念： 断言是编程术语，表示为一些布尔表达式，程序员相信在程序中的某个特定点该表达式值为真，可以在任何时候启用和禁用断言验证，因此可以在测试时启用断言而在部署时禁用断言。 一言以蔽之，老子&#x2F;老娘说啥就是啥！听起来好像挺霸道的。那么具体呢？ 顺着karma的正常流程向下走，我们来写一个简单的单元测试。在终端输入： 1karma init 你会发现，需要做一个调查问卷了，问题如下： 1234567891011121314151617181920212223242526272829303132&gt; 请问你要用哪种测试框架呢？&gt; 按tab键选择，按回车键进入下一个问题。&gt; jasmine (因为我们安装的是jasmine，选什么断言库都别忘了安装一下)&gt; 您想要使用Require.js么？ &gt; 选择yes的话，会安装Require.js插件。&gt; 按tab键选择，按回车键进入下一个问题。 &gt; no (这里我们选择no)&gt; 你想要在什么浏览器中测试呢？ &gt; 按tab键选择，输入空字符串进入下一个问题。 &gt; Chrome&gt; PhantomJS&gt;注：上面的选择这两个浏览器的原因是我们之前安装了这两个浏览器的启动器（launcher）&gt; 需要测试的源文件和测试命令文件放在哪呢？你可以使用通配符(glob patterns)来匹配文件，比如：&quot;js/*.js&quot; 或 &quot;test/**/*Spec.js&quot;输入空字符串进入下一个问题。 &gt;(这里先留空，可根据测试情况灵活配置)&gt;在符合匹配的文件中有哪些文件可以排除在外呢？你可以使用通配符来匹配文件，比如：&quot;**/*.swp&quot;输入空字符串进入下一个问题。 &gt; &gt; 你想要Karma根据文件的变化立即做出响应么？&gt; yes 之后，你就会发现你的文件夹里多了一个文件： 打开这个文件，你会发现里面是一个配置项函数： 1234567891011121314module.exports = function(config) &#123; basePath: &#x27;&#x27;, // 根路径将会同files和excluede项中的相对路径相关联 frameworks: [&#x27;jasmine&#x27;], // 所使用的测试框架 files: [], // 这里是需要测试的文件列表，有多种配置方式 exclude: [], // 测试过程中排除在外的文件列表 reporters: [&#x27;progress&#x27;], // 测试结果的汇报方式， port: 9876, // web服务器接口 colors: true, // 是否使用彩色报告 logLevel: config.LOG_INFO, // 日志级别，可配置的值有: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG autoWatch: true, // 是否自动观测文档改变并执行测试命令 browsers: [&quot;Chrome&quot;, &quot;PhantomJS&quot;], // 用哪些浏览器测试呢 singleRun: false, // 持续集成模式，如果设置成true，Karma将自行捕获浏览器，运行测试并根据结果退出, concurrency: Infinity // 并发数，同时跑多少个浏览器进行测试，默认无上限&#125; 默认会生成的配置项就是上面这些，更完整的配置请点我这里稍微提一下browsers配置项，它可以配置高达8种浏览器： 每一种都需要安装对应的launcher。其中有两个需要注意chromeHeadless和PhantomJS。这两个是无头浏览器。所谓无头浏览器就是没有脑袋的浏览器。 无头浏览器即headless browser，是一种没有界面的浏览器。既然是浏览器那么浏览器该有的东西它都应该有，只是看不到界面而已。因此这种浏览器没有渲染UI的过程，用于测试时的速度很快。 这就回答了上文launcher是啥的问题。毕竟，没有浏览器靠脑补可没法测试啊（真实） 言归正传。我们回到karma测试本身。接下来，我们修改一下配置： 1files: [&quot;src/srcTest/**/*.js&quot;, &quot;test/unit/**/*.js&quot;] 注意，上述写法只是配置写法中的一种, 配置的文件位置也是随您自己指定，更详细的配置请点我 采用上文写法的话，我们在files数组里面配置的第一项是需要测试的文件，第二项就是用什么方法去测试它的文件。 因此，我们也在文件里创建对应的文件夹： 这里有一个要注意的点。我们的需要测试的文件和测试驱动文件的名字是一一对应的，区别就在于测试驱动文件的名字后要加上**.spec** 那么我们就在srcTest的文件里面写点什么吧…. newBee.js 123456// 减法函数function minus(x) &#123; return function(y) &#123; return x - y; &#125;;&#125; testKarma.js 123456789101112131415161718192021222324252627// 加法函数function add(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;// 乘法函数function multi(x) &#123; return function(y) &#123; return x * y; &#125;;&#125;//if函数测试function ifTest(boolean) &#123; if (boolean) &#123; return &quot;热热&quot;; &#125; else &#123; return &quot;凉凉&quot;; &#125;&#125;// 反转字符串function reverseStr (string) &#123; return string.split(&quot;&quot;).reverse().join(&quot;&quot;);&#125; 那么接下来，就在.spec文件里写入对应的测试断言。我滴个龟龟，终于说到断言了。 因为我们这里使用的是Jasmine，因此就先放一下它的官网。 jasmine.github.iohttps://jasmine.github.io/api/edge/global 我们结合实例来说文档 newBee.spec.js 123456describe(&quot;newBee单元测试&quot;, function() &#123; it(&quot;减法函数测试&quot;, function() &#123; var minus7 = minus(7); expect(minus7(6)).toBe(0); &#125;);&#125;); testKarma.spec.js 123456789101112describe(&quot;testKarma单元测试&quot;, function() &#123; it(&quot;如果函数测试&quot;, function() &#123; expect(ifTest(true)).toBe(true); expect(ifTest(false)).toBe(&quot;凉凉&quot;); &#125;); it(&quot;回文函数测试&quot;, function() &#123; expect(reverseStr(&#x27;abc&#x27;)).toEqual(&#x27;cba&#x27;); &#125;)&#125;); 基本的格式就是这样的，下面来解释一下 1234567891011121314151617181920212223242526// 分组describe(), 这个是可以嵌套的，并且每个单独的测试都有beforeAll, afterAll, beforeEach和afterEachdescribe(&quot;这里写测试群组的名称&quot;, function()&#123; // 具体的测试，it(), 当其中所有的断言都为true时，则通过；否则失效。 it(&#x27;这里写具体测试的名称&#x27;, function()&#123; var a = true; // 期望, expect()。 匹配，to*() // 每个匹配方法在期望值和实际值之间执行逻辑比较 // 它负责告诉jasmine断言的真假，从而决定测试的成功或失败 // 木有错，老子/老娘说啥就是啥 expect(a).toBe(true); // 这是肯定断言 expect(!a).not.toBe(true); // 这是否定断言 // jasmine内置的匹配方法有很多，亦可自定义匹配方法 // toBe() // toEqual() // toMatch() // toBeUndefined() // toBeNull() // toBeTruthy() // toContain() // toBeLessThan() // toBeCloseTo() // toThrowError() // 等等等等 &#125;)&#125;) 那么，测试方法写完了，我们来实际运行一下测试吧。打开终端，输入： 1karma start 就会在终端看到 可以看到，我们的测试在Chrome和PhantomJS浏览器中分别测试了的5个方法，都有2个没有通过测试，没错，我们当初在写测试的时候故意写错了（这是真的）。 那么我们把测试修改成真值。 newBee.spec.js 123456describe(&quot;newBee单元测试&quot;, function() &#123; it(&quot;减法函数测试&quot;, function() &#123; var minus7 = minus(7); expect(minus7(6)).toBe(1); &#125;);&#125;); testKarma.spec.js 1234it(&quot;如果函数测试&quot;, function() &#123; expect(ifTest(true)).toBe(&quot;热热&quot;); expect(ifTest(false)).toBe(&quot;凉凉&quot;);&#125;); 结果是： 全部SUCCESS, 撒花。 到这里，一个基本的测试流程就走完了。然而，这并非终点。 其实，还能更进一步的。我们打开终端： 1npm install karma-coverage --save-dev 然后打开karma.conf.js, 添加一些配置项 12345678910111213141516// 这里配置哪些文件需要统计测试覆盖率，例如，如果你的所有代码文件都在src文件夹中，你就需要如下配置preprocessors: &#123; &quot;src/srcTest/*.js&quot;: &quot;coverage&quot;&#125;,// 新增coverageReporter选项// 配置覆盖率报告的查看方式，type查看类型，可以取值html、text等等，dir输出目录coverageReporter: &#123; dir: &quot;docs/unit&quot;, reporters: [ &#123; type: &quot;html&quot;, subdir: &quot;report-html&quot; &#125; ]&#125;,reporters: [&#x27;progress&#x27;, &quot;coverage&quot;] // 没错，reporters里面新增了一个coverage 然后保存，再运行一次karma start 接着会发现你的项目里多了一个文件夹 用浏览器打开index.html。就会看到 这就是你所写的js的测试覆盖率。 这样看起来是不是高大上了一些呢？ 这里就有一个问题了。普通的js可以测试，可是我是写Vue的啊，Vue组件怎么测试呢？很简单，Vue官网有非常详细的测试教程。甚至还有专用的测试工具和测试说明 彳亍口巴，你说的这些个单元测试看起来花里胡哨的，实际作用是什么呢？ 单元测试的好处 单元测试不但会使你的工作完成得更轻松。而且会令你的设计会变得更好，甚至大大减少你花在调试上面的时间。 提高代码质量 减少bug, 快速定位bug 使修改和重构可以更放心 显得专业 单元测试的缺点 开发人员要花费时间在写测试代码上，然而又不会给你加工资…小项目写测试只能单纯的增加开发时间和成本，然而又不会给你加工资…我写了测试除了懂测试的人能看懂，别人又不知道，然而还不会给你加工资… 别别别，别打我…你先听我道(hu)理(jiao)讲(man)完(chan)。 对于所编写的代码，你在调试上面画了多少时间？ 对于以前你自认为正确的代码，而实际上这些代码却存在重大的bug，你花了多少时间在重新确认这些代码上面？ 对于一个别人报告的bug，你花了多少时间才找出导致这个bug的源码位置？ 对于那些没有使用单元测试的程序员而言，上面这些问题所耗费的时间的是逐渐增加的，而且项目越深入，花费的时间越多；另一方面，适当的单元测试却可以很大程度地减少这些时间，从而为你腾出足够的时间来编写所有的单元测试——甚至可能还有剩余的空闲时间。 更加真实的是，主流的框架必须要写测试 不想当程序员的设计师不是好运维。 —-鲁迅 作为一个程序员，如果你想要让自己写的框架放到github和npm上能够为世界上的其他人所用。那么一个最基本的前提就是————代码没有BUG。可是，你的怎么向语言不通思维不同的人解释你的JavaScript库确实足够健壮呢。这个时候就需要单元测试出场了。 主流前端框架虽然在所使用的测试库（karma、jest、QUnit）和断言库（assert、jasmine、 chai）上略有差别，但Vue、React、Angular、Underscore甚至是jQuery都写了单元测试。 来个石锤 下面我们看一看Vue的测试是怎么写的： 1234git clone https://github.com/vuejs/vue.gitnpm installnpm run test unit // 这里可以看到单元测试npm run test // 这里就看全部的测试 Vue的测试覆盖率为 举例：v-show的测试 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// import Vue from &#x27;vue&#x27;describe(&#x27;Directive v-show&#x27;, () =&gt; &#123; it(&#x27;should check show value is truthy&#x27;, () =&gt; &#123; const vm = new Vue(&#123; template: &#x27;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&#x27;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) &#125;) it(&#x27;should check show value is falsy&#x27;, () =&gt; &#123; const vm = new Vue(&#123; template: &#x27;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&#x27;, data: &#123; foo: false &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) &#125;) it(&#x27;should update show value changed&#x27;, done =&gt; &#123; const vm = new Vue(&#123; template: &#x27;&lt;div&gt;&lt;span v-show=&quot;foo&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&#x27;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) vm.foo = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.foo = &#123;&#125; &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) vm.foo = 0 &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.foo = [] &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) vm.foo = null &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.foo = &#x27;0&#x27; &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) vm.foo = undefined &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.foo = 1 &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) &#125;).then(done) &#125;) it(&#x27;should respect display value in style attribute&#x27;, done =&gt; &#123; const vm = new Vue(&#123; template: &#x27;&lt;div&gt;&lt;span v-show=&quot;foo&quot; style=&quot;display:block&quot;&gt;hello&lt;/span&gt;&lt;/div&gt;&#x27;, data: &#123; foo: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&#x27;block&#x27;) vm.foo = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.foo = true &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;block&#x27;) &#125;).then(done) &#125;) it(&#x27;should support unbind when reused&#x27;, done =&gt; &#123; const vm = new Vue(&#123; template: &#x27;&lt;div v-if=&quot;tester&quot;&gt;&lt;span v-show=&quot;false&quot;&gt;&lt;/span&gt;&lt;/div&gt;&#x27; + &#x27;&lt;div v-else&gt;&lt;span @click=&quot;tester=!tester&quot;&gt;show&lt;/span&gt;&lt;/div&gt;&#x27;, data: &#123; tester: true &#125; &#125;).$mount() expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) vm.tester = false waitForUpdate(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;&#x27;) vm.tester = true &#125;).then(() =&gt; &#123; expect(vm.$el.firstChild.style.display).toBe(&#x27;none&#x27;) &#125;).then(done) &#125;)&#125;) 只要你的测试覆盖率足够高，你就可以在著名的GitHub装逼网站Codecov搞一个覆盖率标签了。就像下面这个： 怎么样，这样你所写的框架，是不是就逼格满满？ 所以你还在等什么，测不了吃亏，测不了上当，赶紧在自己的代码中加入测试吧，只要998，代码逼格带回家！","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://www.ryanshang.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"单元测试","slug":"单元测试","permalink":"https://www.ryanshang.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}]},{"title":"封装一个浏览器文本复制功能的方法","slug":"封装一个浏览器文本复制功能的方法","date":"2019-01-11T16:00:00.000Z","updated":"2019-04-13T11:38:25.910Z","comments":true,"path":"2019/01/12/封装一个浏览器文本复制功能的方法/","link":"","permalink":"https://www.ryanshang.com/2019/01/12/%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AA%E6%B5%8F%E8%A7%88%E5%99%A8%E6%96%87%E6%9C%AC%E5%A4%8D%E5%88%B6%E5%8A%9F%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"这段时间，某个需求中，有个功能，需要点击一个button复制某段显示出来的text，于是需要自己动手简单封装一个copy方法。 首先，完成复制，必须调用document的一个api： 1document.execCommand(&#x27;copy&#x27;); execCommand的api链接：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand 这个是必须的，接下来，来介绍下大体思路：","text":"这段时间，某个需求中，有个功能，需要点击一个button复制某段显示出来的text，于是需要自己动手简单封装一个copy方法。 首先，完成复制，必须调用document的一个api： 1document.execCommand(&#x27;copy&#x27;); execCommand的api链接：https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand 这个是必须的，接下来，来介绍下大体思路： 在document中建立一个看不见的input 把需要复制的文字复制给input的value 选择这些文字 调用document.execCommand(&#39;copy&#39;); 在第三步有个兼容性问题，安卓手机可以直接调用input的select方法选中文字，但是iOS调用select方法只会选中，并不会默认选中文字，必须手动执行一个setSelectionRange方法来选中这些文字。否则，iOS上的复制无法生效。 12345678910111213141516171819202122232425function copy (text) &#123; var input = document.createElement(&#x27;input&#x27;); input.setAttribute(&#x27;readonly&#x27;, &#x27;readonly&#x27;); input.style.position = &#x27;fixed&#x27;; input.style.top = 0; input.style.left = 0; input.style.border = &#x27;none&#x27;; input.style.outline = &#x27;none&#x27;; input.style.resize = &#x27;none&#x27;; input.style.background = &#x27;transparent&#x27;; input.style.color = &#x27;transparent&#x27;; input.value = text; document.body.appendChild(input); if (utils.isIOS()) &#123; input.setSelectionRange(0, text.length); &#125; else &#123; input.select(); &#125; try &#123; document.execCommand(&#x27;copy&#x27;); &#125; catch (err) &#123; console.log(&#x27;unable to copy&#x27;, err); &#125; document.body.removeChild(input);&#125; 这样一个文本复制的方法就完成了。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"刮卡效果滑动轨迹偏移","slug":"刮卡效果滑动轨迹偏移","date":"2018-12-21T16:00:00.000Z","updated":"2019-04-13T11:41:57.080Z","comments":true,"path":"2018/12/22/刮卡效果滑动轨迹偏移/","link":"","permalink":"https://www.ryanshang.com/2018/12/22/%E5%88%AE%E5%8D%A1%E6%95%88%E6%9E%9C%E6%BB%91%E5%8A%A8%E8%BD%A8%E8%BF%B9%E5%81%8F%E7%A7%BB/","excerpt":"1. 问题描述 初始需求要求一个刮刮卡的效果，代码完成后，发现计算没有问题，但是结果和触摸点偏移，如上图（仅供参考，不代表实际情况） 2. 原因","text":"1. 问题描述 初始需求要求一个刮刮卡的效果，代码完成后，发现计算没有问题，但是结果和触摸点偏移，如上图（仅供参考，不代表实际情况） 2. 原因 经排查发现，因为需要使刮卡区域居中，使用了css3属性transform中的translateX。但该属性会对触摸的相关计算产生影响，导致偏差，修改为其他方式居中解决。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"}]},{"title":"小程序调研报告","slug":"小程序调研报告","date":"2018-12-09T16:00:00.000Z","updated":"2019-04-13T08:12:39.703Z","comments":true,"path":"2018/12/10/小程序调研报告/","link":"","permalink":"https://www.ryanshang.com/2018/12/10/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/","excerpt":"一、目的结合团队现阶段技术栈，找到目前最适合团队快速上手小程序的技术栈。 二、框架1. 现有框架对比 1 小程序 wepy mpvue megalo Taro 语法规范 小程序规范 类Vue规范 Vue规范 Vue规范 React规范 模板系统 字符串模板 字符串模板 字符串模板 字符串模板 JSX 类型系统 不支持 业务代码 业务代码 业务代码 业务代码 + JSX模板 组件规范 小程序组件 小程序组件 html标签 + 小程序组件 html标签 + 小程序组件 小程序组件 样式规范 wxss sass, less, stylus sass, less, postcss sass, less, postcss 组件化 小程序组件化 自定义组件化 Vue组件化规范 Vue组件化规范 React组件化规范 多端复用 无 复用为H5 复用为H5，将通过Weex支持移动端 复用为H5 复用为H5，将通过RN支持移动端 自动构建 无 内建构件系统 Webpack构建 内建构建系统 + Webpack构建 内建构建系统 + Webpack构建 上手成本 全新学习 熟悉Vue + wepy 熟悉Vue 熟悉Vue 熟悉React 数据流管理 无 Redux Vuex Vuex Redux","text":"一、目的结合团队现阶段技术栈，找到目前最适合团队快速上手小程序的技术栈。 二、框架1. 现有框架对比 1 小程序 wepy mpvue megalo Taro 语法规范 小程序规范 类Vue规范 Vue规范 Vue规范 React规范 模板系统 字符串模板 字符串模板 字符串模板 字符串模板 JSX 类型系统 不支持 业务代码 业务代码 业务代码 业务代码 + JSX模板 组件规范 小程序组件 小程序组件 html标签 + 小程序组件 html标签 + 小程序组件 小程序组件 样式规范 wxss sass, less, stylus sass, less, postcss sass, less, postcss 组件化 小程序组件化 自定义组件化 Vue组件化规范 Vue组件化规范 React组件化规范 多端复用 无 复用为H5 复用为H5，将通过Weex支持移动端 复用为H5 复用为H5，将通过RN支持移动端 自动构建 无 内建构件系统 Webpack构建 内建构建系统 + Webpack构建 内建构建系统 + Webpack构建 上手成本 全新学习 熟悉Vue + wepy 熟悉Vue 熟悉Vue 熟悉React 数据流管理 无 Redux Vuex Vuex Redux 2. mpvue和megalo对比(1) 不同点对比 1 mpvue megalo vue语法支持程度 大部分vue语法 mpvue基础上，多支持filter，v-html，slot-scope，复杂差值表达式 单页面结构 vue页面文件、小程序配置文件、js文件 vue页面文件、js文件（配置文件放在vue页面文件中） 新增页面操作 修改app.json 修改app.json + 修改webpack配置 文档详细程度 起步早，相对丰富 起步晚，文档简单 (2) 试用megalo 出现问题（后期更新可能解决） megalo iconPath要用相对定位，否则报错 1234567// index.js&#123; &quot;pagePath&quot;: &quot;pages/index/index&quot;, &quot;text&quot;: &quot;首页&quot;, &quot;iconPath&quot;: &quot;../static/2018-12-10-小程序调研报告/index.png&quot;, &quot;selectedIconPath&quot;: &quot;../static/2018-12-10-小程序调研报告/index-active.png&quot;&#125; megalo pages可以用^标志首页，但增加页面需要改webpack entry 123456789// webpack.base.config.jsentry: &#123; &#x27;app&#x27;: _.resolve( &#x27;src/index.js&#x27; ), &#x27;pages/index/index&#x27;: _.resolve( &#x27;src/pages/index/index.js&#x27; ), &#x27;pages/logs/index&#x27;: _.resolve( &#x27;src/pages/logs/index.js&#x27; ), &#x27;pages/create/index&#x27;: _.resolve( &#x27;src/pages/create/index.js&#x27; ), &#x27;pages/table/index&#x27;: _.resolve( &#x27;src/pages/table/index.js&#x27; ), &#x27;pages/record/index&#x27;: _.resolve( &#x27;src/pages/record/index.js&#x27; ),&#125; megalo没有自己的vue-cli模板，初始化项目比较麻烦 megalo每个页面的vue文件需要设置mpType: ‘page’ 12345678910// index.vueexport default &#123; mpType: &#x27;page&#x27;, data () &#123; return &#123; motto: &#x27;Hello World&#x27;, userInfo: &#123;&#125; &#125; &#125;&#125; megalo用小程序开发工具指向的是dist，个人感觉有时报错需要重启小程序开发工具或者删除dist重新打包才能解决 用官方megalo-demo，项目可以跑起来，新增页面无问题，但无法引第三方ui库，引用静态资源无法打包到dist中（因时间原因，无法具体研究webpack配置需要怎么写） 使用vue-cli初始化项目，根据官网文档修改webpack配置后编译，框架需要的一个包直接报错（因时间原因，不再具体研究） 三、UI库1. 不能使用常见前端移动端UI库的原因小程序架构如图： 整个小程序由两个 webview 组成，代码分为 UI 层和逻辑层。UI 层运行在第一个 WebView 当中，执行 DOM 操作和交互事件的响应，里面是 WAWebview.js 代码及编译后的内容。逻辑层执行在（第二个webview 中）独立的 JS 引擎中（iOS：JavaScriptCore, android：X5 JS解析器；统称 JSCore；开发工具中，nwjs Chrome 内核），WAService.js 代码和业务逻辑。 当我们对 view 层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层。View 渲染更新视图。 UI和逻辑分开，有两个好处，一个是并行处理避免js运行时间长导致ui卡顿加快首屏渲染，另一个是不支持DOM操作，完全数据驱动。 按照小程序官方文档说明，页面的脚本逻辑是在JsCore中运行，JsCore是一个没有窗口对象的环境，所以不能在脚本中使用window，也无法在脚本中操作组件。 2. 小程序常见UI库对比 WeUI iView WeApp Vant WeApp Wux WeApp MinUI 组件数量 20+ 30+ 30+ 60+ 30+ github star数 7.6k+ 2.8k+ 7.1k+ 2.3k+ 2.8k+ 半年内open issue数 &lt;10 190+ 10+ 10+ 20+ 半年内closed issue数 &lt;10 40+ 320+ 60+ &lt;10 半年内版本更新次数 0 &lt;10 20+ 10+ &lt;10 数据截止2018年11月 经过测试，UI库组件在一般项目开发中性能差距不大，结合上表数据来看，Vant的开发人员是最活跃的，使用人数最多，可以作为选择。 3. mpvue引入UI库（vant&#x2F;iview&#x2F;wux）方式(1) 下载组件库（download zip&#x2F;git clone&#x2F;npm）获取ui库的dist文件夹并放入项目static中 (2) 更改配置Webpack.base.config&#x3D;&gt;module&#x3D;&gt;rules 1234567891011121314// webpack.base.config.js&#123; test: /\\.js$/, include: [resolve(&#x27;src&#x27;), resolve(&#x27;test&#x27;), resolve(&#x27;static/vant&#x27;)], use: [ &#x27;babel-loader&#x27;, &#123; loader: &#x27;mpvue-loader&#x27;, options: &#123; checkMPEntry: true &#125; &#125;, ]&#125; (3) 引入组件在要使用组件的页面文件夹下的main.json中（没有新建），引入组件 1234567// main.json&#123; &quot;usingComponents&quot;: &#123; &quot;v-button&quot;: &quot;/static/vant/button/index&quot;, &quot;v-icon&quot;: &quot;/static/vant/icon/index&quot; &#125;&#125; (4) 使用组件在.vue文件中的template标签中直接使用，不需要import引入 四、采坑（mpvue + vant） 使用vant需要开启小程序ES6转ES5功能（右上角——详情），否则报错 Notify和Dialog import引入需要相对路径，否则无法找到模块 使用ui框架，双向绑定需要自己绑定change事件，mpvue做了双向绑定，但是只针对于input radio和checkbox和cell-group嵌套使用，因无法获取component，无法按照vant官方文档操作，只能点击勾选的对号进行选择，或者自己封装onchange事件 12345678910111213141516171819&lt;!-- html结构 --&gt;&lt;v-checkbox-group :value=&quot;tablePropList&quot; @change=&quot;handleChange&quot;&gt; &lt;v-cell-group&gt; &lt;v-cell v-for=&quot;(item, index) in tablePropListData&quot; :key=&quot;index&quot; :title=&quot;item.label&quot; :data-prop=&quot;item.prop&quot; clickable @click=&quot;handleCheckboxClick($event, item, index)&quot;&gt; &lt;v-checkbox :class=&quot;&#x27;checkbox-&#x27; + item.prop&quot; :name=&quot;item.prop&quot;&gt; &lt;/v-checkbox&gt; &lt;/v-cell&gt; &lt;/v-cell-group&gt;&lt;/v-checkbox-group&gt; 123456789101112131415161718// vant官网方法handleCheckboxClick (e, item, index) &#123; // 无法获取checkbox let &#123; prop &#125; = e.currentTarget.dataset let checkbox = this.$root.$mp.page.selectComponent(`.checbox-$&#123;prop&#125;`) checkbox.toggle()&#125;// 自己编写change事件触发的方法handleCheckboxClick (e, item, index) &#123; let prop = item.prop if (this.tablePropList.includes(prop)) &#123; let index = this.tablePropList.indexOf(prop) this.tablePropList.splice(index, 1) &#125; else &#123; this.tablePropList.push(prop) &#125;&#125; 在mpvue中，page实例获取方式是this.$root.mp.page，在vue文件中的this指向vue实例 五、结论现阶段结合自身情况，使用 mpvue + vant 是最合适的方案，vant组件满足不了需求的，需要自己封装业务组件。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://www.ryanshang.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"自己封装方法整理","slug":"自己封装方法整理","date":"2018-11-23T16:00:00.000Z","updated":"2019-04-14T03:16:02.551Z","comments":true,"path":"2018/11/24/自己封装方法整理/","link":"","permalink":"https://www.ryanshang.com/2018/11/24/%E8%87%AA%E5%B7%B1%E5%B0%81%E8%A3%85%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/","excerpt":"这里整理了一些自己封装的方法。 1. 类名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 通过类名查找元素 * @param strClass 一个或多个类名 * @param context 上下文 范围(可选) 默认是document */function getByClass(strClass, context) &#123; context = context || document; if (document.getElementsByClassName) &#123; return nodeListToArray(context.getElementsByClassName(strClass)); &#125; var aryClass = strClass.match(/\\S+/); var eles = nodeListToArray(context.getElementsByTagName(&#x27;*&#x27;)); for (var i = 0; i &lt; aryClass; i++) &#123; var reg = new RegExp(&#x27;(^| +)&#x27; + aryClass[i] + &#x27;( +|$)&#x27;); for (var j = 0; j &lt; eles.length; j++) &#123; if (!reg.test(eles[i].className)) &#123; eles.splice(j, 1); j--; &#125; &#125; &#125; return eles;&#125;/** * * @param ele 当前元素 * @param strClass 单个类名 * @return true|false */function hasClass(ele, strClass) &#123; var reg = new RegExp(&quot;(^| +)&quot; + strClass + &quot;( +|$)&quot;); return reg.test(ele.className)&#125;/** * 添加类名 * @param ele 当前的元素 * @param strClass 一个类名或多个类名 */function addClass(ele, strClass) &#123; var aryClass = strClass.replace(/(^\\s+|\\s+$)/g, &quot;&quot;).split(/\\s+/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; if (!hasClass(ele, curClass)) &#123; // 若没有这个类名,才添加 ele.className += &quot; &quot; + curClass; &#125; &#125;&#125;/** * 删除类名 * @param ele 当前元素 * @param strClass 一个类名或多个类名 */function removeClass(ele, strClass) &#123; //拆分strClass,把每个类名拿到 var aryClass = strClass.replace(/^ +| +$/g, &quot;&quot;).split(/ +/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; // 每个类名 // 判断是否有这个类名,若有这个类名,则把这个类名删了 var reg = new RegExp(&quot;(^| +)&quot; + curClass + &quot;( +|$)&quot;, &quot;g&quot;); if (hasClass(ele, curClass)) &#123; ele.className = ele.className.replace(reg, &quot; &quot;); &#125; &#125;&#125; 2. CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 获取任意css样式 * @param ele 当前元素 * @param attr css属性 */function getCss(ele, attr) &#123; var res = null; if (typeof getComputedStyle == &quot;function&quot;) &#123; res = window.getComputedStyle(ele, null)[attr]; &#125; else &#123; if (attr == &quot;opacity&quot;) &#123; res = ele.currentStyle.filter;//&quot;alpha(opacity = 50)&quot; var reg = /^alpha\\(opacity\\s*=\\s*(\\d+(?:\\.\\d+)?)\\)$/; // reg.exec(res)[1] RegExp.$1 res = reg.test(res) ? RegExp.$1 / 100 : 1; &#125; else &#123; res = ele.currentStyle[attr]; &#125; &#125; // 对单位的处理 // 若获取值是-&gt;左边是数值,右边是单位,则把单位去掉并转化成数类型 var reg = /^[+-]?(?:\\d+(?:\\.\\d+)?)(?:px|rem|pt|em)?$/i; return reg.test(res) ? parseFloat(res) : res;&#125;/** * * @param ele 当前元素 * @param attr css属性 * @param value css属性值 */function setCss(ele, attr, value) &#123; // 1.对浮动处理 if (attr == &quot;float&quot;) &#123; ele.style.cssFloat = value; ele.style.styleFloat = value; return; &#125; // 2.对透明度处理 if (attr == &quot;opacity&quot;) &#123; ele.style.opacity = value; ele.style.filter = &quot;alpha(opacity =&quot; + value * 100 + &quot;)&quot;; return; &#125; // 3.设置单位-对没有设置单位的添加单位 var reg = /^(?:width|height|((?:margin|padding)?(?:top|bottom|left|right)?))$/i; if (reg.test(attr) &amp;&amp; !isNaN(value)) value = value + &#x27;px&#x27;; ele.style[attr] = value;&#125;/** * 批量设置css样式 * @param ele 当前元素 * @param opt 对象类型 -每一项是css属性和css属性值 */function setGroup(ele, opt) &#123; //先检测opt的数据类型 if (Object.prototype.toString.call(opt) !== &quot;[object Object]&quot;) return; for (var attr in opt) &#123; setCss(ele, attr, opt[attr]); &#125;&#125;/** *通过参数确定是调用哪个方法(getCss,setCss,setGroup) */function css() &#123; var fn = getCss; if (arguments.length === 3) fn = setCss; if (arguments.length === 2 &amp;&amp; typeof arguments[1] === &#x27;object&#x27;) fn = setCssGroup; return fn.apply(null, arguments);&#125;","text":"这里整理了一些自己封装的方法。 1. 类名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 通过类名查找元素 * @param strClass 一个或多个类名 * @param context 上下文 范围(可选) 默认是document */function getByClass(strClass, context) &#123; context = context || document; if (document.getElementsByClassName) &#123; return nodeListToArray(context.getElementsByClassName(strClass)); &#125; var aryClass = strClass.match(/\\S+/); var eles = nodeListToArray(context.getElementsByTagName(&#x27;*&#x27;)); for (var i = 0; i &lt; aryClass; i++) &#123; var reg = new RegExp(&#x27;(^| +)&#x27; + aryClass[i] + &#x27;( +|$)&#x27;); for (var j = 0; j &lt; eles.length; j++) &#123; if (!reg.test(eles[i].className)) &#123; eles.splice(j, 1); j--; &#125; &#125; &#125; return eles;&#125;/** * * @param ele 当前元素 * @param strClass 单个类名 * @return true|false */function hasClass(ele, strClass) &#123; var reg = new RegExp(&quot;(^| +)&quot; + strClass + &quot;( +|$)&quot;); return reg.test(ele.className)&#125;/** * 添加类名 * @param ele 当前的元素 * @param strClass 一个类名或多个类名 */function addClass(ele, strClass) &#123; var aryClass = strClass.replace(/(^\\s+|\\s+$)/g, &quot;&quot;).split(/\\s+/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; if (!hasClass(ele, curClass)) &#123; // 若没有这个类名,才添加 ele.className += &quot; &quot; + curClass; &#125; &#125;&#125;/** * 删除类名 * @param ele 当前元素 * @param strClass 一个类名或多个类名 */function removeClass(ele, strClass) &#123; //拆分strClass,把每个类名拿到 var aryClass = strClass.replace(/^ +| +$/g, &quot;&quot;).split(/ +/g); for (var i = 0; i &lt; aryClass.length; i++) &#123; var curClass = aryClass[i]; // 每个类名 // 判断是否有这个类名,若有这个类名,则把这个类名删了 var reg = new RegExp(&quot;(^| +)&quot; + curClass + &quot;( +|$)&quot;, &quot;g&quot;); if (hasClass(ele, curClass)) &#123; ele.className = ele.className.replace(reg, &quot; &quot;); &#125; &#125;&#125; 2. CSS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 获取任意css样式 * @param ele 当前元素 * @param attr css属性 */function getCss(ele, attr) &#123; var res = null; if (typeof getComputedStyle == &quot;function&quot;) &#123; res = window.getComputedStyle(ele, null)[attr]; &#125; else &#123; if (attr == &quot;opacity&quot;) &#123; res = ele.currentStyle.filter;//&quot;alpha(opacity = 50)&quot; var reg = /^alpha\\(opacity\\s*=\\s*(\\d+(?:\\.\\d+)?)\\)$/; // reg.exec(res)[1] RegExp.$1 res = reg.test(res) ? RegExp.$1 / 100 : 1; &#125; else &#123; res = ele.currentStyle[attr]; &#125; &#125; // 对单位的处理 // 若获取值是-&gt;左边是数值,右边是单位,则把单位去掉并转化成数类型 var reg = /^[+-]?(?:\\d+(?:\\.\\d+)?)(?:px|rem|pt|em)?$/i; return reg.test(res) ? parseFloat(res) : res;&#125;/** * * @param ele 当前元素 * @param attr css属性 * @param value css属性值 */function setCss(ele, attr, value) &#123; // 1.对浮动处理 if (attr == &quot;float&quot;) &#123; ele.style.cssFloat = value; ele.style.styleFloat = value; return; &#125; // 2.对透明度处理 if (attr == &quot;opacity&quot;) &#123; ele.style.opacity = value; ele.style.filter = &quot;alpha(opacity =&quot; + value * 100 + &quot;)&quot;; return; &#125; // 3.设置单位-对没有设置单位的添加单位 var reg = /^(?:width|height|((?:margin|padding)?(?:top|bottom|left|right)?))$/i; if (reg.test(attr) &amp;&amp; !isNaN(value)) value = value + &#x27;px&#x27;; ele.style[attr] = value;&#125;/** * 批量设置css样式 * @param ele 当前元素 * @param opt 对象类型 -每一项是css属性和css属性值 */function setGroup(ele, opt) &#123; //先检测opt的数据类型 if (Object.prototype.toString.call(opt) !== &quot;[object Object]&quot;) return; for (var attr in opt) &#123; setCss(ele, attr, opt[attr]); &#125;&#125;/** *通过参数确定是调用哪个方法(getCss,setCss,setGroup) */function css() &#123; var fn = getCss; if (arguments.length === 3) fn = setCss; if (arguments.length === 2 &amp;&amp; typeof arguments[1] === &#x27;object&#x27;) fn = setCssGroup; return fn.apply(null, arguments);&#125; 3. 标签名1234567891011121314151617181920212223242526/** * 获取到指定标签名的子元素 * @param context 上下文 * @param tagName 标记名 (字符串) */function children(context, tagName) &#123; var ary = []; // 1.先获取所有的子节点 var eles = context.childNodes; for (var i = 0; i &lt; eles.length; i++) &#123; // 2.判断是否元素节点 if (eles[i].nodeType === 1) &#123; // 3.判断tagName是否正确 if (typeof tagName === &#x27;string&#x27;) &#123; // 把相同标记名的元素放入数组中 if (eles[i].nodeName.toLowerCase() === tagName.toLowerCase()) &#123; ary.push(eles[i]); &#125; &#125; else &#123; // 第二个参数错误 ary.push(eles[i]); &#125; &#125; &#125; return ary;&#125; 4. forEach&#x2F;Map12345678910111213141516171819202122232425Array.prototype.myForEach = function (callback, context) &#123; //浏览器性能优化 if ([].forEach) &#123; this.forEach(callback, context); return; &#125; //this指的是调用forEach方法的数组 context = context || window; //以后callback运行时改变回调函数的this for (var i = 0; i &lt; this.length; i++) &#123; //this[i]数组的每一项，i指索引，this指的原数组本身 callback.call(context, this[i], i, this); &#125;&#125;;Array.prototype.myMap = function (callback, context) &#123; if ([].map) &#123; return this.map(callback, context) &#125; context = context || window; var ary = []; for (var i = 0; i &lt; this.length; i++) &#123; ary.push(callback.call(context, this[i], i, this)); &#125; return ary;&#125;; 5. NodeList123456789101112131415/** * NodeList转换成数组 * @param nodeList */function nodeListToArray(likeAry) &#123; var ary = []; try &#123; ary = [].slice.call(likeAry); &#125; catch (e) &#123; for (var i = 0; i &lt; likeAry.length; i++) &#123; ary.push(likeAry[i]); &#125; &#125; return ary;&#125; 6. UA检测12345678910111213/** * 检测是否移动端 */function isMoblie () &#123; return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase())&#125;/** * 检测是否iOS */function isIOS () &#123; return /iphone|ipad|ipod/i.test(navigator.userAgent.toLowerCase())&#125; 7. url12345678910111213/** * 把url的参数转换成对象 */function getQuery () &#123; var res = &#123;&#125;; var search = window.location.search; var temp = search.slice(1).split(&#x27;&amp;&#x27;); temp.forEach(function (item, index) &#123; var query = item.split(&#x27;=&#x27;); res[query[0]] = query[1] &#125;) return res&#125; 8. jsonp1234567891011121314151617181920212223242526272829303132333435363738function jsonp(opt)&#123; var handleParams = function (_default, opt) &#123; var obj = &#123;&#125;; for (var key in _default) &#123; if (_default.hasOwnProperty(key)) &#123; obj[key] = opt[key] || _default[key]; &#125; &#125; return obj; &#125;; var _default = &#123; url: &#x27;&#x27;, query: &#x27;&#x27;, callback: &#x27;&#x27;, success: null, error: null, charset: &#x27;&#x27; &#125;; opt = handleParams(_default, opt); var script = document.createElement(&quot;script&quot;), head = document.head; script.src = opt.url + &#x27;?&#x27; + opt.query; script.setAttribute(&#x27;type&#x27;, &#x27;text/javascript&#x27;); opt.charset &amp;&amp; script.setAttribute(&#x27;charset&#x27;, opt.charset); window[opt.callback] = function (data) &#123; opt.success &amp;&amp; opt.success(data); delete window[opt.callback]; &#125;; script.onerror = function (error) &#123; error &amp;&amp; opt.error(); delete window[opt.callback]; &#125; script.onload = function () &#123; head.removeChild(script); script = null; &#125; head.appendChild(script);&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"Flat函数","slug":"Flat函数","date":"2018-06-15T16:00:00.000Z","updated":"2019-04-15T11:19:49.366Z","comments":true,"path":"2018/06/16/Flat函数/","link":"","permalink":"https://www.ryanshang.com/2018/06/16/Flat%E5%87%BD%E6%95%B0/","excerpt":"经常会遇到需要把数组展开的面试题，比如把数组[&#39;j&#39;,[&#39;a&#39;,&#39;r&#39;],&#39;v&#39;,[&#39;a,&#39;n&#39;],[5,[2,0]]]展开变成[&quot;j&quot;, &quot;a&quot;, &quot;r&quot;, &quot;v&quot;, &quot;a&quot;, &quot;n&quot;, 5, 2, 0]。常见方式肯定是递归，今天发现了一种利用ES6新特性的方式，记录下来张张见识。 先写下比较常见的递归方式： 1234567891011121314let flat1 = (arr) =&gt; &#123; let res = [] let flat = (target) =&gt; &#123; if (target instanceof Array) &#123; target.forEach(item =&gt; &#123; flat(item); &#125;) &#125; else &#123; res.push(target); &#125; &#125; flat(arr); return res&#125;; 接着是利用ES6遍历器的方式： 123456789101112131415161718192021222324252627282930313233let flat2 = (arr) =&gt; &#123; Array.prototype[Symbol.iterator] = function () &#123; let arr = [].concat(this); let getFirst = (array) =&gt; &#123; let first = array.shift(); if (first instanceof Array) &#123; if (first.length &gt; 1) &#123; arr = first.slice(1).concat(array); &#125; first = first[0]; &#125; return first; &#125;; return &#123; next: function () &#123; let item = getFirst(arr); if (item !== undefined) &#123; return &#123; value: item, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125;; let res = []; for (let i of arr) &#123; res.push(i); &#125; return res;&#125;;","text":"经常会遇到需要把数组展开的面试题，比如把数组[&#39;j&#39;,[&#39;a&#39;,&#39;r&#39;],&#39;v&#39;,[&#39;a,&#39;n&#39;],[5,[2,0]]]展开变成[&quot;j&quot;, &quot;a&quot;, &quot;r&quot;, &quot;v&quot;, &quot;a&quot;, &quot;n&quot;, 5, 2, 0]。常见方式肯定是递归，今天发现了一种利用ES6新特性的方式，记录下来张张见识。 先写下比较常见的递归方式： 1234567891011121314let flat1 = (arr) =&gt; &#123; let res = [] let flat = (target) =&gt; &#123; if (target instanceof Array) &#123; target.forEach(item =&gt; &#123; flat(item); &#125;) &#125; else &#123; res.push(target); &#125; &#125; flat(arr); return res&#125;; 接着是利用ES6遍历器的方式： 123456789101112131415161718192021222324252627282930313233let flat2 = (arr) =&gt; &#123; Array.prototype[Symbol.iterator] = function () &#123; let arr = [].concat(this); let getFirst = (array) =&gt; &#123; let first = array.shift(); if (first instanceof Array) &#123; if (first.length &gt; 1) &#123; arr = first.slice(1).concat(array); &#125; first = first[0]; &#125; return first; &#125;; return &#123; next: function () &#123; let item = getFirst(arr); if (item !== undefined) &#123; return &#123; value: item, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125;; let res = []; for (let i of arr) &#123; res.push(i); &#125; return res;&#125;; 这种方式就比较惊艳，充分利用ES6新特性，值得好好深入研究，这里就先记录下，待后续深入研究下遍历器。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"https://www.ryanshang.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"数组排序","slug":"数组排序","date":"2018-05-19T16:00:00.000Z","updated":"2019-04-14T03:31:27.039Z","comments":true,"path":"2018/05/20/数组排序/","link":"","permalink":"https://www.ryanshang.com/2018/05/20/%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/","excerpt":"数组排序的几种方法。 冒泡排序123456789101112131415161718192021function bubbleSort(ary) &#123; var flag = false; var temp = null; for (var i = 0; i &lt; ary.length - 1; i++) &#123; for (var j = 0; j &lt; ary.length - 1 - i; j++) &#123; if (ary[j] &gt; ary[j + 1]) &#123; temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; flag = true; &#125; &#125; // 一轮过后没有变化，则已经是结果 if (flag) &#123; flag = false; &#125; else &#123; break; &#125; &#125; return ary;&#125; 插入排序12345678910111213141516171819function insertSort(ary) &#123; var newAry = []; newAry.push(ary[0]); for (var i = 1; i &lt; ary.length; i++) &#123; var cur = ary[i]; for (var j = newAry.length - 1; j &gt;= 0;) &#123; if (cur &lt; newAry[j]) &#123; j--; if (j === -1) &#123; newAry.unshift(cur); &#125; &#125; else &#123; newAry.splice(j + 1, 0, cur); j = -1; &#125; &#125; &#125; return newAry;&#125;","text":"数组排序的几种方法。 冒泡排序123456789101112131415161718192021function bubbleSort(ary) &#123; var flag = false; var temp = null; for (var i = 0; i &lt; ary.length - 1; i++) &#123; for (var j = 0; j &lt; ary.length - 1 - i; j++) &#123; if (ary[j] &gt; ary[j + 1]) &#123; temp = ary[j]; ary[j] = ary[j + 1]; ary[j + 1] = temp; flag = true; &#125; &#125; // 一轮过后没有变化，则已经是结果 if (flag) &#123; flag = false; &#125; else &#123; break; &#125; &#125; return ary;&#125; 插入排序12345678910111213141516171819function insertSort(ary) &#123; var newAry = []; newAry.push(ary[0]); for (var i = 1; i &lt; ary.length; i++) &#123; var cur = ary[i]; for (var j = newAry.length - 1; j &gt;= 0;) &#123; if (cur &lt; newAry[j]) &#123; j--; if (j === -1) &#123; newAry.unshift(cur); &#125; &#125; else &#123; newAry.splice(j + 1, 0, cur); j = -1; &#125; &#125; &#125; return newAry;&#125; 快速排序1234567891011121314function quickSort(ary) &#123; if (ary.length &lt;= 1) &#123; return ary; &#125; var pointIndex = Math.floor(ary.length / 2); var pointValue = ary.splice(pointIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; ary.length; i++) &#123; var cur = ary[i]; cur &lt; pointValue ? left.push(cur) : right.push(cur); &#125; return quickSort(left).concat([pointValue], quickSort(right));&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"ES5继承","slug":"ES5继承","date":"2018-05-03T16:00:00.000Z","updated":"2019-04-14T02:26:49.630Z","comments":true,"path":"2018/05/04/ES5继承/","link":"","permalink":"https://www.ryanshang.com/2018/05/04/ES5%E7%BB%A7%E6%89%BF/","excerpt":"面向对象编程有三大特征：封帐、继承、多态。 严格意义上来说，JavaScript是没有继承和多态的，所以需要我们自己来实现，今天来讲讲ES5的继承实现方法。 我个人认为，最好的继承方案，应该是父类私有的属性和方法拿到子类上用，父类公有的属性和方法直接通过__proto__查找到。 要实现父类的私有属性和方法拿到子类上来用，最简单的方式就是用call方法。 1234567891011function Father() &#123; this.x = 10; this.y = 20;&#125;Father.prototype.fn=function () &#123; console.log(this.x);&#125;;function Son() &#123; //this-&gt;实例 Father.call(this); //父类上的私有属性拷贝一份放到子类的实例上&#125;","text":"面向对象编程有三大特征：封帐、继承、多态。 严格意义上来说，JavaScript是没有继承和多态的，所以需要我们自己来实现，今天来讲讲ES5的继承实现方法。 我个人认为，最好的继承方案，应该是父类私有的属性和方法拿到子类上用，父类公有的属性和方法直接通过__proto__查找到。 要实现父类的私有属性和方法拿到子类上来用，最简单的方式就是用call方法。 1234567891011function Father() &#123; this.x = 10; this.y = 20;&#125;Father.prototype.fn=function () &#123; console.log(this.x);&#125;;function Son() &#123; //this-&gt;实例 Father.call(this); //父类上的私有属性拷贝一份放到子类的实例上&#125; 这样，私有属性和方法的继承就完成了，接下来，我们看怎么继承公有属性和方法。 首先，把父类的prototype直接赋值给子类： 1Son.prototype = Father.prototype; 这样会导致互相污染，肯定是行不通的。接着，能想到的方式肯定是把父类实例化一个实例出来，然后子类的prototype改为这个实例： 1Son.prototype = new Father(); 这样确实子类可以拿到父类的公有属性和方法，但是这个做法会导致子类的实例和原型上都会有父类的私有属性和方法。这个方式明显就不合适了。 为了只拿到公有属性和方法，试试直接简单粗暴的把父类原型上的属性和方法拷贝一份放在子类原型上： 123456function copy(Father, Son) &#123; for(var attr in Father)&#123; Son[attr] = Father[attr]; &#125;&#125;copy(Father.prototype, Son.prototype); 这样就不会对子类的原型造成污染，但是同样有问题：比较占空间，尤其是父类越来越复杂的时候。 这样的话，貌似借助一个临时的空类是一个不错的选择。 1234function Temp () &#123;&#125;Temp.prototype = Father.prototype;Son.prototype = new Temp(); // 将子类的原型变成临时类的实例Son.prototype.constructor = Son; // 最后别忘了把constructor改回来 这样既可以拿到父类的私有方法和属性，子类的原型上也会有父类的公有属性和方法。 最后来整体看下： 123456789101112131415161718function myCreate(obj) &#123; //obj指的是父类的原型 function Temp () &#123;&#125; Temp.prototype = obj; return new Temp;&#125;function Father() &#123; this.x = 10; this.y = 20;&#125;Father.prototype.fn=function () &#123; console.log(this.x);&#125;;function Son() &#123; Father.call(this);&#125;Son.prototype = myCreate(Father.prototype);Son.prototype.constructor = Son; 这样就完成了一个比较不错的继承，其实myCreate方法应该可以看作一个简化的Object.create()方法","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"CSS垂直居中","slug":"CSS垂直居中","date":"2018-04-14T16:00:00.000Z","updated":"2019-05-13T07:24:27.142Z","comments":true,"path":"2018/04/15/CSS垂直居中/","link":"","permalink":"https://www.ryanshang.com/2018/04/15/CSS%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","excerpt":"1. 行内元素123456.parent &#123; height: X; /* X为一个绝对高度 */&#125;.child &#123; line-hight: X;&#125; 2. Table1234567.parent &#123; display: table;&#125;.child &#123; display: table-cell; vertical-align: middle;&#125; 3. 绝对定位（left+height）","text":"1. 行内元素123456.parent &#123; height: X; /* X为一个绝对高度 */&#125;.child &#123; line-hight: X;&#125; 2. Table1234567.parent &#123; display: table;&#125;.child &#123; display: table-cell; vertical-align: middle;&#125; 3. 绝对定位（left+height）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; height: X; /* X为一个绝对高度 */ top: 50%; margin-top: -0.5*X&#125; 4. 绝对定位（transform）123456789.parent &#123; position: releative;&#125;.child &#123; position: absolute; top: 50%; transform: translate(0, -50%);&#125; 5. 绝对定位（top+bottom）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; top: 0; bottom: 0; margin: auto 0;&#125; 6. Flex布局1234.parent &#123; display: flex; align-items: center;&#125; 7. Grid布局1234.parent &#123; display: grid; align-items: center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"}]},{"title":"CSS水平居中","slug":"CSS水平居中","date":"2018-04-06T16:00:00.000Z","updated":"2019-04-14T01:03:19.641Z","comments":true,"path":"2018/04/07/CSS水平居中/","link":"","permalink":"https://www.ryanshang.com/2018/04/07/CSS%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/","excerpt":"1. 行内元素123.parent &#123; text-align: center;&#125; 2. 块级元素123div &#123; margin: 0 auto;&#125; 3. 绝对定位（left+width）","text":"1. 行内元素123.parent &#123; text-align: center;&#125; 2. 块级元素123div &#123; margin: 0 auto;&#125; 3. 绝对定位（left+width）12345678910.parent &#123; position: releative;&#125;.child &#123; position: absolute; width: X; /* X为一个绝对宽度 */ left: 50%; margin-right: -0.5*X&#125; 4. 绝对定位（transform）123456789.parent &#123; position: releative;&#125;.child &#123; position: absolute; left: 50%; transform: translate(-50%, 0);&#125; 5. Flex布局1234.parent &#123; display: flex; justify-content: center;&#125; 6. Grid布局1234.parent &#123; display: grid; justify-items: center;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"}]},{"title":"跨域的方式","slug":"跨域的方式","date":"2018-01-27T16:00:00.000Z","updated":"2019-04-15T01:43:16.843Z","comments":true,"path":"2018/01/28/跨域的方式/","link":"","permalink":"https://www.ryanshang.com/2018/01/28/%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%96%B9%E5%BC%8F/","excerpt":"说到跨域就不得不提一个东西——同源策略。 什么是同源策略？同源策略&#x2F;SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 虽然同源策略提高了安全性，但是业务和开发中总会遇到需要跨域的场景，今天大概记录下常见的跨域方式的原里，具体实现待以后有机会补充。","text":"说到跨域就不得不提一个东西——同源策略。 什么是同源策略？同源策略&#x2F;SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送 虽然同源策略提高了安全性，但是业务和开发中总会遇到需要跨域的场景，今天大概记录下常见的跨域方式的原里，具体实现待以后有机会补充。 1. jsonp利用脚本src可以跨域的特性，前端在页面中插入一个script标签，和后端商定好函数名，我们在全局定义这个函数，后端返回执行这个函数的js代码，参数是需要传输的数据。 2. location.hash + iframe利用hash值变化页面不刷新的特性，配合window.onhashchange事件做到跨域传输数据。 3. window.name + iframe利用name值在不同的页面（甚至不同域名）加载后依旧存在的特性，并且可以支持非常长的 name 值（2MB）。 4. postMessagepostMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage(data, origin)需要和window.addEventListener(&#39;message&#39;, function()&#123;&#125;)配合使用 5. WebSocketWebSocket是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。 6. CORS跨域资源共享，可以看作是ajax的升级版。 CORS首先分为简单请求和非简单请求。 只要同时满足以下两大条件，就属于简单请求： （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求后端需要设置以下属性： Access-Control-Allow-Origin 非简单请求后端需要设置以下属性： Access-Control-Allow-Origin Access-Control-Allow-Credentials Access-Control-Request-Method Access-Control-Allow-Headers 前端需要设置withCredentials 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 7. Proxynginx或者node.js转发请求做代理。 node.js做代理比较常见的就是vue cli中的proxy设置了，配合hosts方便开发。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"三栏布局","slug":"三栏布局","date":"2018-01-19T16:00:00.000Z","updated":"2019-04-14T10:35:33.162Z","comments":true,"path":"2018/01/20/三栏布局/","link":"","permalink":"https://www.ryanshang.com/2018/01/20/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%80/","excerpt":"这几天看到一个面试题： 已知高度，完成一个三栏布局，左侧200px，右侧200px，中间自适应。 题目看起来不难，第一时间能想起来三种方案：Float、Absolute和Flex，后来发现还有两种：Table和Grid，所以来记录下。 首先写下公共的CSS样式： 1234567891011121314151617181920212223242526html * &#123; margin: 0; padding: 0;&#125;.left &#123; background: red; width: 200px;&#125;.center &#123; background: yellow;&#125;.right &#123; background: blue; width: 200px;&#125;.container &#123; min-height: 100px; margin: 20px; width: 100%;&#125;.left-center-right &#123; min-height: 100px;&#125;.left-center-right&gt;div &#123; min-height: 100px;&#125;","text":"这几天看到一个面试题： 已知高度，完成一个三栏布局，左侧200px，右侧200px，中间自适应。 题目看起来不难，第一时间能想起来三种方案：Float、Absolute和Flex，后来发现还有两种：Table和Grid，所以来记录下。 首先写下公共的CSS样式： 1234567891011121314151617181920212223242526html * &#123; margin: 0; padding: 0;&#125;.left &#123; background: red; width: 200px;&#125;.center &#123; background: yellow;&#125;.right &#123; background: blue; width: 200px;&#125;.container &#123; min-height: 100px; margin: 20px; width: 100%;&#125;.left-center-right &#123; min-height: 100px;&#125;.left-center-right&gt;div &#123; min-height: 100px;&#125; 下面来写下五种写法： 1. Float兼容性好，但是会影响文档流 123456789101112&lt;section class=&quot;container float&quot;&gt; &lt;div class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Float&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456.container.float .left &#123; float: left;&#125;.container.float .right &#123; float: right;&#125; 2. Absolute兼容性好，但是会影响文档流 123456789101112&lt;section class=&quot;container absolute&quot;&gt; &lt;div class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Absolute&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345678910111213141516.container.absolute &#123; position: relative;&#125;.container.absolute .left &#123; position: absolute; left: 0;&#125;.container.absolute .center &#123; position: absolute; left: 200px; right: 200px;&#125;.container.absolute .right &#123; position: absolute; right: 0;&#125; 3. Table兼容性好，但是比较老旧，布局比较麻烦，已经很少见 123456789101112&lt;section class=&quot;container table&quot;&gt; &lt;div class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Table&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345678910111213.container.table .left-center-right &#123; display: table; width: 100%;&#125;.container.table .left &#123; display: table-cell;&#125;.container.table .center &#123; display: table-cell;&#125;.container.table .right &#123; display: table-cell;&#125; 4. Flex兼容性较好，在移动端很常用，写法简单。 123456789101112&lt;section class=&quot;container flex&quot;&gt; &lt;div class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Flex&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 123456.container.flex .left-center-right &#123; display: flex;&#125;.container.flex .center &#123; flex: 1;&#125; 5. Grid兼容性不是很好，但是写法最为简单。 123456789101112&lt;section class=&quot;container grid&quot;&gt; &lt;div class=&quot;left-center-right&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Grid&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 12345.container.grid .left-center-right &#123; display: grid; grid-template-rows: 100px; grid-template-columns: 200px 1fr 200px;&#125; 最后，如果题目修改，高度未定的时候，这五种布局还都能成功么？ 经过测试，增加中间div的内容使之超出div的高度 123456789&lt;div class=&quot;center&quot;&gt; &lt;h2&gt;Grid&lt;/h2&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt; &lt;p&gt;中间部分&lt;/p&gt;&lt;/div&gt; 对比下结果： 正常情况： 添加内容后： 可以看出： Table和Flex布局能正常撑开容器高度，未知高度情况下可以考虑这两个方案 Float布局中间div高度变高，超出部分被宽度会和left-center-right一样，文字从最左边开始 Absolute布局会只撑开中间div的高度 Grid容器和div高度不会改变，但是因为grid-template-rows的设定，文字会超出容器","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"},{"name":"面试题","slug":"面试题","permalink":"https://www.ryanshang.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"Ajax","slug":"Ajax","date":"2017-11-24T16:00:00.000Z","updated":"2019-04-14T23:50:55.157Z","comments":true,"path":"2017/11/25/Ajax/","link":"","permalink":"https://www.ryanshang.com/2017/11/25/Ajax/","excerpt":"","text":"记录下自己封装的Ajax。 Ajax四步骤： 创建一个XHR对象 打开一个链接地址 监听请求状态 发送数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788let ajax = (options) =&gt; &#123; // 将传入的参数和默认值合并 let extend = (_old, _new) =&gt; &#123; let obj = &#123;&#125;; for (let key in _old) &#123; if (!_old.hasOwnProperty(key)) continue; if (!/^(cache|async)$/.test(key)) &#123; obj[key] = _new[key] || _old[key]; &#125; else &#123; obj[key] = key in _new ? _new[key] : _old[key]; &#125; &#125; return obj; &#125;; // 判断请求的url里是否有?，若有说明已有传输的数据，再添加时以&amp;隔开，若没有?则添加? let hasSearch = (url) =&gt; url = url.indexOf(&#x27;?&#x27;) &gt; -1 ? &#x27;&amp;&#x27; : &#x27;?&#x27;; // 把对象&#123;name:&#x27;Ryan&#x27;,age:20&#125;转个成一个uri格式字符串&#x27;name=&quot;Ryan&quot;&amp;age=20 let encodeObjURI = (data) =&gt; &#123; let str = &#x27;&#x27;; for (let key in data) &#123; str += `$&#123;key&#125;=$&#123;encodeURIComponent(data[key])&#125;&amp;`; &#125; str = str.slice(0, str.length - 1); return str; &#125;; let _default = &#123; type: &#x27;get&#x27;, url: null, async: true, cache: true, data: null, dataType: &#x27;text&#x27;, success: null, error: null &#125;; _default = extend(_default, options); let &#123; type, url, async, cache, data, dataType, success, error &#125; = _default; // 1.创建ajax对象 let xhr = new XMLHttpRequest(); // 对get系列方式判断 get|delete|head let regGet = /^(get|delete|head)$/i; // 对post系列方式进行判断 let regPost = /^(post|put)$/i; if (!regGet.test(type) &amp;&amp; !regPost.test(type)) return; // 数据存在，则把数据放在url后 if (data) &#123; if (Object.prototype.toString.call(data) === &#x27;[object Object]&#x27;) &#123; data = encodeObjURI((data)); // 对象转换成uri格式字符串 &#125; if (regGet.test(type)) &#123; url += `$&#123;hasSearch(url)&#125;$&#123;data&#125;`; data = null; &#125; &#125; // 处理缓存，若是get方式并且不需要缓存 cache = false if (regGet.test(type) &amp;&amp; cache === false) &#123; url += `$&#123;hasSearch(url)&#125;_=$&#123;Math.random()&#125;`; &#125; // 2.打开一个链接地址 xhr.open(type, url, async); // 3.监听请求 xhr.onreadystatechange = function () &#123; if (xhr.readyState === 4 &amp;&amp; /^2\\d&#123;2&#125;$/.test(xhr.status)) &#123; let result = xhr.responseText; switch (dataType) &#123; case &#x27;json&#x27;: result = &#x27;JSON&#x27; in window ? JSON.parse(result) : eval(&#x27;(&#x27; + result + &#x27;)&#x27;); break; case &#x27;xml&#x27;: result = xhr.responseXML; break; &#125; success &amp;&amp; success(result); &#125; if (xhr.readyState === 4 &amp;&amp; /^(4|5)\\d&#123;2&#125;$/.test(xhr.status)) &#123; error &amp;&amp; error(xhr); &#125; &#125;; // 4.发送数据 xhr.send(data); // 只能是字符串，get方式为null，post方式才把数据放在请求体里&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"Chromebook利用Crouton安装Ubuntu卡google解决办法","slug":"Chromebook利用Crouton安装Ubuntu卡google解决办法","date":"2017-10-21T16:00:00.000Z","updated":"2019-04-14T23:51:47.353Z","comments":true,"path":"2017/10/22/Chromebook利用Crouton安装Ubuntu卡google解决办法/","link":"","permalink":"https://www.ryanshang.com/2017/10/22/Chromebook%E5%88%A9%E7%94%A8Crouton%E5%AE%89%E8%A3%85Ubuntu%E5%8D%A1google%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"利用crouton自带参数更改软件源 1$ sudo sh ~/Downloads/crouton -r xenial -m http://mirror.163.com/ubuntu -t core,audio,keyborad,touch,xfce-desktop","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"}],"tags":[{"name":"Chromebook","slug":"Chromebook","permalink":"https://www.ryanshang.com/tags/Chromebook/"}]},{"title":"Ubuntu16.04和Win10双系统时间错乱修复","slug":"Ubuntu16-04和Win10双系统时间错乱修复","date":"2017-10-21T16:00:00.000Z","updated":"2019-04-14T23:51:57.797Z","comments":true,"path":"2017/10/22/Ubuntu16-04和Win10双系统时间错乱修复/","link":"","permalink":"https://www.ryanshang.com/2017/10/22/Ubuntu16-04%E5%92%8CWin10%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E9%94%99%E4%B9%B1%E4%BF%AE%E5%A4%8D/","excerpt":"首先进入Ubuntu更新时间。 12$ sudo apt-get install ntpdata$ sudo ntpdate time.windows.com 然后将时间更新到硬件中。 1$ sudo hwclock --localttime --systohc 重新进入Win10，查看时间是否正常。","text":"首先进入Ubuntu更新时间。 12$ sudo apt-get install ntpdata$ sudo ntpdate time.windows.com 然后将时间更新到硬件中。 1$ sudo hwclock --localttime --systohc 重新进入Win10，查看时间是否正常。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.ryanshang.com/tags/Ubuntu/"}]},{"title":"Adblock Plus检测","slug":"Adblock Plus检测","date":"2017-09-16T16:00:00.000Z","updated":"2018-08-11T10:21:50.167Z","comments":true,"path":"2017/09/17/Adblock Plus检测/","link":"","permalink":"https://www.ryanshang.com/2017/09/17/Adblock%20Plus%E6%A3%80%E6%B5%8B/","excerpt":"​ Adblock Plus是现在很多用户会安装的一些浏览器扩展插件，用来屏蔽使用浏览器浏览时页面中的插件。 ​ 最近在写一个静态页面时，发现有张图片加载不出来，图片名为ad.jpg，调试了之后发现是浏览器的Adblock Plus把这张图片屏蔽掉了。 ​ 刚开始没在意，后来浏览知乎和cnBeta时，发现都有因为使用Adblock Plus出现的提示，就突然很好奇，Adblock Plus检测是怎么实现的，自己根据写项目时的情况，实现了下检测Adblock Plus的功能。 要解决的问题： ​ 在不影响页面布局的情况下，检测用户是否使用Adblock Plus插件。","text":"​ Adblock Plus是现在很多用户会安装的一些浏览器扩展插件，用来屏蔽使用浏览器浏览时页面中的插件。 ​ 最近在写一个静态页面时，发现有张图片加载不出来，图片名为ad.jpg，调试了之后发现是浏览器的Adblock Plus把这张图片屏蔽掉了。 ​ 刚开始没在意，后来浏览知乎和cnBeta时，发现都有因为使用Adblock Plus出现的提示，就突然很好奇，Adblock Plus检测是怎么实现的，自己根据写项目时的情况，实现了下检测Adblock Plus的功能。 要解决的问题： ​ 在不影响页面布局的情况下，检测用户是否使用Adblock Plus插件。 主要代码如下： 12345678let testAdblock = () =&gt; &#123; let img = new Image(); img.src = &#x27;img/ad.jpg&#x27;; //img.src = &#x27;images/ad.jpg&#x27;; img.onerror = function () &#123; alert(&#x27;您使用了Adblock插件&#x27;); &#125;;&#125;; 大体思路如下： 创建一个图片对象 给这个图片对象添加一个路径属性src 通过图片的onerror事件检测图片是否成功加载 ​ 创建一个图片对象是为了不更改界面布局，添加src属性后，如果图片被插件屏蔽，是无法加载成功的。 需要改进的地方： 需要增加一次请求，需要考虑是否可以用其他资源代替 没有检测图片资源是否能访问到，有可能onerror事件触发是因为资源获取不到 onerror是个事件，事件函数处理过程是异步的，所以如果真的投入生产工作中，还需要进一步完善 很有意思的一点，不知道是不是Adblock Plus规则问题，我的Adblock Plus插件屏蔽规则是EasyList China+EasyList。在试验过程中，图片必须放在img文件夹或者images文件夹中，就像代码中的那两种。放在根目录和image文件夹中都无法触发Adblock Plus的屏蔽功能 ​ 这次也就是大体上思考并且动手实践了一下，很多细节都没有去处理，以后还会在继续研究一下。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.ryanshang.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"console.log()是同步还是异步？","slug":"console.log是同步还是异步","date":"2017-08-26T16:00:00.000Z","updated":"2018-08-11T10:21:50.166Z","comments":true,"path":"2017/08/27/console.log是同步还是异步/","link":"","permalink":"https://www.ryanshang.com/2017/08/27/console.log%E6%98%AF%E5%90%8C%E6%AD%A5%E8%BF%98%E6%98%AF%E5%BC%82%E6%AD%A5/","excerpt":"​ 最近在研究对象深拷贝的时候无意间发现了这样一个现象： 1234let obj = &#123;name: &#x27;Ryan&#x27;,info:&#123;name:&#x27;Ryan&#x27;&#125;&#125;;console.log(obj);obj.info.name = &#x27;Shang&#x27;;console.log(obj); ​ 在html中写上这段代码，在chrome浏览器中执行的结果是这样： ![chrome console结果](2017-01-01-console.log是同步还是异步&#x2F;chrome console结果.png) ​ obj.info.name的值竟然在第一次打印的时候就变了？难不成console.log是一个异步操作？","text":"​ 最近在研究对象深拷贝的时候无意间发现了这样一个现象： 1234let obj = &#123;name: &#x27;Ryan&#x27;,info:&#123;name:&#x27;Ryan&#x27;&#125;&#125;;console.log(obj);obj.info.name = &#x27;Shang&#x27;;console.log(obj); ​ 在html中写上这段代码，在chrome浏览器中执行的结果是这样： ![chrome console结果](2017-01-01-console.log是同步还是异步&#x2F;chrome console结果.png) ​ obj.info.name的值竟然在第一次打印的时候就变了？难不成console.log是一个异步操作？ ​ 接着我在node环境中试验了一下： ![node console结果](2017-01-01-console.log是同步还是异步&#x2F;node console结果.png) ​ 结果正常。 ​ 继续测试，我更改了下代码： 1234let obj = &#123;name: &#x27;Ryan&#x27;,info:&#123;name:&#x27;Ryan&#x27;&#125;&#125;;console.log(JSON.stringify(obj));obj.info.name = &#x27;Shang&#x27;;console.log(JSON.stringify(obj)); ​ 结果是这样： ![chrome stringify结果](2017-01-01-console.log是同步还是异步&#x2F;chrome stringify结果.png) ​ 这样更疑惑了。 ​ 代码在node环境中运行和在字符串化后都正常。那么可能就是Chrome控制台的一个bug？ ​ 在Google上搜寻了相关内容，结果比较有意思。 ​ Chrome的控制台在处理对象时，有可能保存的是对象的引用地址。控制台对于引用地址的对象属性变化的更新可能是比较懒的，可能当你需要使用这个对象或对其进行操作时，它才会更新。所以，当你直接打印对象时，显示的是最近的状态，但你对obj进行操作后，显示的值就会更新为正确的值。 ​ 大概就是这个原因导致文中的情况，不过究竟如何，还需要深入研究，可能我现在的思考结果也不一定对。 参考资料： https://stackoverflow.com/questions/23392111/console-log-async-or-sync https://stackoverflow.com/questions/4057440/is-chromes-javascript-console-lazy-about-evaluating-arrays","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.ryanshang.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}]},{"title":"Vue.js学习笔记","slug":"Vue.js学习笔记","date":"2017-08-19T16:00:00.000Z","updated":"2023-09-28T21:49:02.854Z","comments":true,"path":"2017/08/20/Vue.js学习笔记/","link":"","permalink":"https://www.ryanshang.com/2017/08/20/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"库和框架库 别人写好的内容由我们主动调用 常见库：jQuery Underscore Zepto Animate.css 框架 拥有完整的解决方案，我们写好内容交给框架调用 常见框架：vue angular react backbone","text":"库和框架库 别人写好的内容由我们主动调用 常见库：jQuery Underscore Zepto Animate.css 框架 拥有完整的解决方案，我们写好内容交给框架调用 常见框架：vue angular react backbone 架构模式MVC模式 单项数据绑定 backbone Model 模型 View 视图 Controller 控制器 MVVM模式 双向数据绑定 vue，angular Model 模型 View 视图 ViewModel 视图模型 vuevue的优点 只关注视图层，不需要操作DOM 轻量级，压缩后只有不到20k 渐进式框架，根据需求选择 vue的兼容性​ Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能模拟的 ECMAScript 5 特性。 vue的安装12# 最新稳定版$ npm install vue { { } }​ { { } }取值表达式，通过{ { } }来进行取值，默认可以不写this，支持表达式、赋值运算、计算和三元表达式 。尽量少写逻辑运算（computed） 指令 v-开头的行内属性 v-model 实现双向数据绑定（看到表单元素加v-model）,忽略掉value，checked，selected，将数据绑定的视图上，视图修改后会影响数据的变化。 v-html 把html字符串渲染成html标签 v-text 把数据渲染成文本，{ { } }是v-text简写写法 v-for 循环（数组，对象，字符串，数字） v-on 事件 v-on:click-&gt;@click 绑定给DOM元素，函数需要定义在methods中，不能和data中的内容重名，this指向实例，不能使用箭头函数，事件源对象如果不写括号，可以自动传入，否则只能手动传入$event 修饰符 .number数字 .lazy离开修饰符 按键修饰符 .enter .ctrl .keyCode 事件相关 @事件.stop stopPropagation,cancelBubble&#x3D;trued 阻止事件传播 @事件.capture xxx.addEventLister(‘click’,fn,true) @事件.prevent preventDefault,returnValue&#x3D;false @事件.once jQuery once; on ‘click’ off ‘click’ @事件.self e.srcElement&amp;&amp;e.target 判断事件源绑定事件 v-if 操作DOM v-else-if 操作DOM v-else 操作DOM v-show 样式上的显示和隐藏 频繁的控制显示和隐藏 v-once 数据只渲染一次，数据再变化是不会导致视图刷新 v-cloak 相应比较慢的时候，会看到{ { } }，出现闪烁的效果，防止闪烁效果出现 v-bind 动态绑定属性 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;!--:class绑定的样式和class绑定的不冲突--&gt; &lt;!--1.&#123;className:isActive&#125;--&gt; &lt;div class=&quot;x&quot; :class=&quot;&#123;z:flag,y:true&#125;&quot;&gt;啦啦啦&lt;/div&gt; &lt;div class=&quot;x&quot; :class=&quot;[&#x27;y&#x27;,&#x27;z&#x27;]&quot;&gt;哈哈哈&lt;/div&gt; &lt;div class=&quot;x&quot; :class=&quot;[class1,&#123;z:true&#125;]&quot;&gt;呵呵呵&lt;/div&gt; &lt;div class=&quot;x&quot; :class=&quot;&#123;true:&#x27;y&#x27;,false:&#x27;z&#x27;&#125;[true]&quot;&gt;不怎么用&lt;/div&gt; &lt;div v-for=&quot;(a,index) in 10&quot; :class=&quot;&#123;x:index%2===0&#125;&quot;&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;!--动态绑定样式--&gt; &lt;div style=&quot;font-size: 30px;&quot; :style=&quot;&#123;backgroundColor:&#x27;red&#x27;,color:&#x27;pink&#x27;&#125;&quot;&gt;嘿嘿嘿&lt;/div&gt; &lt;div :style=&quot;[sty1,sty2,&#123;fontSize:&#x27;30px&#x27;&#125;]&quot;&gt;略略略&lt;/div&gt;&lt;/div&gt; 123456789let vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; flag:true, class1:&#x27;y&#x27;, sty1:&#123;backgroundColor:&#x27;red&#x27;&#125;, sty2:&#123;color:&#x27;pink&#x27;&#125; &#125;&#125;); data保存变量 1&lt;div id=&quot;app&quot;&gt;&#123;&#123;val&#125;&#125;&lt;/div&gt; 123456let vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123; val:&#x27;Hello world!&#x27; &#125;&#125;); methods定义需要执行的使用的函数方法 1&lt;div id=&quot;app&quot;&gt;&#123;&#123;&#x27;123&#x27;| my&#125;&#125;&lt;/div&gt; 12345678let vm = new Vue(&#123; el:&#x27;#app&#x27;, filters:&#123; my(data,param1,param2)&#123; //do something &#125; &#125;&#125;); filters 过滤器对数据的显示效果进行处理 1&lt;div id=&quot;app&quot;&gt;&#123;&#123;&#x27;123&#x27;| my&#125;&#125;&lt;/div&gt; 12345678let vm = new Vue(&#123; el:&#x27;#app&#x27;, filters:&#123; my(data,param1,param2)&#123; //do something &#125; &#125;&#125;); computed 计算“属性”，不是方法计算属性的值，不需要在data中再次声明 1234&lt;div id=&quot;app&quot;&gt; 全选&lt;input type=&quot;checkbox&quot; v-model=&quot;checkAll&quot;&gt;&lt;br&gt; &lt;input type=&quot;checkbox&quot; v-for=&quot;product in products&quot; v-model=&quot;product.isSelected&quot;&gt;&lt;/div&gt; 123456789101112131415161718let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; products: [&#123;isSelected: true&#125;, &#123;isSelected: true&#125;, &#123;isSelected: true&#125;] &#125;, computed: &#123; checkAll: &#123; get() &#123; return this.products.every(item =&gt; item.isSelected); &#125;, set(val) &#123; //val是给checkAll复制的时候传递过来的 this.products.forEach(item =&gt; &#123; item.isSelected = val; &#125;); &#125; &#125; &#125; &#125;); watch 监测属性变化监测属性变化，属性变化则执行对应方法 1234&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;a&quot;&gt; &#123;&#123;msg&#125;&#125;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; a: &#x27;&#x27;, msg: &#x27;&#x27; &#125;, watch: &#123; //只有值变化时才会触发，支持异步，其他情况我们更善于使用computed a(newVal, oldVal) &#123; //方法名要和观察对象一致 setTimeout(() =&gt; &#123; if (newVal.length &lt; 3) &#123; this.msg = &#x27;太少&#x27;; return; &#125; if (newVal.length &gt; 6) &#123; this.msg = &#x27;太多&#x27;; return; &#125; this.msg = &#x27;&#x27;; &#125;, 1000); &#125; &#125; &#125;); 生命周期：beforeCreate()​ 触发时机：初始化内部方法和生命周期方法后 created()​ 触发时机：注入数据，完成双向数据绑定后 ​ 一般作用：获取ajax，初始化操作 beforeMount()​ 触发时机：挂载实例和编译模板后，要保证有编译的元素才能执行 mounted()​ 触发时机：真实DOM渲染完成 ​ 一般作用：DOM操作 ​ tips：真实DOM的渲染是异步操作，需要等待DOM渲染完成后来获取。如果数据变化后，想获取真实DOM中的内容，需要等待页面渲染完成后再去获取，所有的DOM操作，最好放在nextTick中执行 beforeUpdate()​ 触发时机：页面依赖的数据需要变化时 ​ 一般作用：不用，用watch代替 updated()​ 触发时机：页面依赖的数据变化，虚拟DOM重新渲染后 ​ 一般作用：不用，用watch代替 beforeDestroy()​ 触发时机：实例销毁前，销毁的是监听 ​ 一般作用：清除定时器，清除事件绑定 destroyed()​ 触发时机：实例销毁后 实例常用方法 this.$mount 挂载实例的另一种方法 this.$data 实例上的数据 this.$watch 监控 this.$el 当前el元素 this.$set 后加的属性实现响应式变化 this.$options 实例上的其他属性 this.$refs ref放在DOM上用来获取DOM元素；放在组件上获取的是组件的实例，并不是组件的DOM元素 this.$nextTick 将回调延迟到下次 DOM 更新循环之后执行 组件概念​ vue把一个自定义标签看作一个组件，vue可以赋予自定义标签一些意义 优点 提高开发效率 方便重复利用 便于协同开发 更容易被管理和维护 用途 页面级组件：一个页面是一个组件 基础组件：将可用的部分抽离出来 用法全局组件：可以声明一次在任何地方使用，写插件的时候用全局属性多一点 12345678Vue.component(&#x27;my-component&#x27;, &#123; //一个对象可以看成一个组件 template: &#x27;&lt;div&gt;Component &#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;, data() &#123; //组件中数据必须是函数类型，返回一个实例作为组件的值 return &#123; msg: &#x27;Test&#x27; &#125;; &#125;&#125;); 局部组件：必须告诉这个组件属于哪个实例 ​ 局部组件创建步骤： ​ 1. 创建组件 ​ 2. 注册组件 ​ 3. 引用组件 ​ 组件是相互独立的，不能直接跨作用域，实力也是一个组件，组件中拥有生命周期函数 ​ 子组件不能直接使用父组件的使用（组件之间数据交互） ​ 组件理论上可以无限嵌套 123456789101112131415161718let component = &#123; template: &#x27;&lt;div&gt;Component &#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;, data() &#123; return &#123; msg: &#x27;Test&#x27; &#125; &#125;&#125;;let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Test&#x27; //子组件获取不到 &#125;, components: &#123; component &#125;&#125;); 命名 组件名不用大写，多个单词用-连接 只要组件名和定义名字相同是可以的（首字母可以大写） html采用短横线隔开命名法，js中采用驼峰命名法 嵌套组件​ 如果要在一个组件中使用另一个组件，先保证使用的组件是真实存在的，在需要引用这个组件的实例上通过components注册这个组件，组件需要在父级的模板中通过标签的形式引入 12345678910111213141516171819202122let grandson = &#123;template: &#x27;&lt;div&gt;Grandson&lt;/div&gt;&#x27;&#125;;let son = &#123; template: &#x27;&lt;div&gt;Son&lt;grandson&gt;&lt;/grandson&gt;&lt;/div&gt;&#x27;, components: &#123; grandson &#125;&#125;;let parent = &#123; template: &#x27;&lt;div&gt;Parent&lt;son&gt;&lt;/son&gt;&lt;/div&gt;&#x27;, components: &#123; son &#125;&#125;;let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, template:&#x27;&lt;parent&gt;&lt;/parent&gt;&#x27;, components:&#123; parent &#125;&#125;); 组件间数据传输——父传子（props）​ 给子组件上添加一个属性，绑定对应的父组件，然后给子组件中增加props属性，把在子组件上添加的属性写进去。 12345&lt;div id=&quot;app&quot;&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--当前组件的属性=父级的值--&gt; &lt;child :m=&quot;money&quot;&gt;&lt;/child&gt;&lt;!--给儿子加了一个m属性，属性对应的数据是属于父亲的--&gt;&lt;/div&gt; 1234567891011121314151617181920let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;money: 400&#125;, components: &#123; child: &#123; props: &#123; m: &#123; //校验属性的类型，如果不带冒号，肯定是字符串，:m=&#x27;1&#x27;数字 :m=&#x27;true&#x27;布尔 type: [String, Boolean, Number, Function, Object, Array],// default: 0, //可以给m赋特殊值，如果不传默认会调用default required: true, //此属性是必须传递，但是不能和default同用 validator(val) &#123; return val &gt; 300; //自定义校验器（用的不多） &#125; &#125; //对象的形式可以校验 &#125;,// props:[&#x27;m&#x27;], //this.m=100; 会在当前子组件上声明一个m属性值是父亲的 template: &#x27;&lt;div&gt;儿子：&#123;&#123;m&#125;&#125;&lt;/div&gt;&#x27; &#125; &#125;&#125;); 组件间数据传输——子传父（emit）​ 父组件绑定好一些事件，子组件触发这个事件，将这个参数传进去，单项数据流，父组件数据刷新，子组件数据刷新 12345&lt;div id=&quot;app&quot;&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--child.on(&#x27;child-msg&#x27;,things)--&gt; &lt;child :m=&quot;money&quot; @child-msg=&quot;things&quot;&gt;&lt;/child&gt;&lt;/div&gt; 12345678910111213141516171819202122let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; money: 200 &#125;, methods: &#123; things(val) &#123; this.money = val; &#125; &#125;, components: &#123; child: &#123; props: [&#x27;m&#x27;], template: &#x27;&lt;div&gt;儿子：&#123;&#123;m&#125;&#125; &lt;br/&gt;&lt;button @click=&quot;getMoney&quot;&gt;多来点&lt;/button&gt;&lt;/div&gt;&#x27;, methods: &#123; getMoney() &#123; this.$emit(&#x27;child-msg&#x27;, this.m * 2); //触发自己的自定义事件，都让父亲的方法执行 &#125; &#125; &#125; &#125;&#125;); 语法糖： 123456&lt;div id=&quot;app&quot;&gt; 父亲：&#123;&#123;money&#125;&#125; &lt;!--&lt;child :m=&quot;money&quot; @update:m=&quot;val =&gt; this.money = val;&quot;&gt;&lt;/child&gt;--&gt; &lt;child :m.sync=&quot;money&quot;&gt;&lt;/child&gt; &lt;!--写的时候还是按照原有的写法即可--&gt;&lt;/div&gt; 1234567891011121314151617let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; money: 200 &#125;, components: &#123; child: &#123; props: [&#x27;m&#x27;], template: &#x27;&lt;div&gt;儿子：&#123;&#123;m&#125;&#125; &lt;br/&gt;&lt;button @click=&quot;getMoney&quot;&gt;多来点&lt;/button&gt;&lt;/div&gt;&#x27;, methods: &#123; getMoney() &#123; this.$emit(&#x27;update:m&#x27;, this.m * 2); &#125; &#125; &#125; &#125;&#125;); 组件间数据传输——兄弟组件（EventBus）​ 通过新建一个vue实例传递事件 1234&lt;div id=&quot;app&quot;&gt; &lt;brother1&gt;&lt;/brother1&gt; &lt;brother2&gt;&lt;/brother2&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647let EventBus = new Vue();let brother1 = &#123; template: &#x27;&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click=&quot;change&quot;&gt;变绿&lt;/button&gt;&lt;/div&gt;&#x27;, data() &#123; return &#123; color: &#x27;绿色&#x27;, old: &#x27;绿色&#x27; &#125; &#125;, created() &#123; EventBus.$on(&#x27;changeRed&#x27;, val =&gt; &#123; //页面一加载兄弟1，长个耳朵听 this.color = val; &#125;); &#125;, methods: &#123; change() &#123; EventBus.$emit(&#x27;changeGreen&#x27;, this.old); &#125; &#125;&#125;;let brother2 = &#123; template: &#x27;&lt;div&gt;&#123;&#123;color&#125;&#125;&lt;button @click=&quot;change&quot;&gt;变红&lt;/button&gt;&lt;/div&gt;&#x27;, data() &#123; return &#123; color: &#x27;红色&#x27;, old: &#x27;红色&#x27; &#125; &#125;, created() &#123; EventBus.$on(&#x27;changeGreen&#x27;, val =&gt; &#123; this.color = val; &#125;); &#125;, methods: &#123; change() &#123; EventBus.$emit(&#x27;changeRed&#x27;, this.old); &#125; &#125;&#125;;let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, components: &#123; brother1, brother2 &#125;&#125;); 插槽slot​ 插槽slot可以在组件中通过给DOM元素赋slot属性，在模板中使用slot标签配合name属性把slot标签替换为对应slot属性的DOM元素。 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;!--这里放的内容均属父级当前模板的，只有属性名属于组件的--&gt; &lt;modal&gt; &lt;a href=&quot;http://www.ryanshang.com&quot;&gt;Ryan&lt;/a&gt; &lt;p slot=&quot;content&quot;&gt;亲，确认删除么？&lt;/p&gt; &lt;h1 slot=&quot;title&quot; @click=&quot;fn&quot;&gt;是否删除？&lt;/h1&gt; &lt;a href=&quot;http://www.ryanshang.com&quot;&gt;Ryan&lt;/a&gt; &lt;/modal&gt; &lt;!--&lt;modal&gt;&lt;span&gt;是否确认？&lt;/span&gt;&lt;/modal&gt;--&gt; &lt;!--&lt;modal&gt;&lt;/modal&gt;--&gt;&lt;/div&gt;&lt;!--模板中只能有一个根元素--&gt;&lt;!--可以通过元素属性定制模板--&gt;&lt;template id=&quot;modal&quot;&gt; &lt;div&gt; &lt;!--slot的作用：定制模板--&gt; &lt;!--slot可以放置一些默认内容，如果传递了内容则替换掉--&gt; &lt;!--如果没有名字的标签默认会放到default中--&gt; &lt;slot name=&quot;title&quot;&gt;默认标题&lt;/slot&gt; &lt;slot name=&quot;content&quot;&gt;默认内容&lt;/slot&gt; &lt;slot name=&quot;default&quot;&gt;这是一个默认标题&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314let modal=&#123; template:&#x27;#modal&#x27;, //把teplate内容放到html中的template标签中，通过id名关联&#125;;let vm = new Vue(&#123; el:&#x27;#app&#x27;, data:&#123;&#125;, components:&#123; modal &#125;, methods:&#123; fn()&#123;alert(1);&#125; &#125;&#125;); keep-alive​ 一般用作缓存，如果已缓存则不会再执行created、mounted钩子函数 ​ 子组件和父组件同时拥有mounted方法，先走子组件 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;home&quot;&gt;home &lt;input type=&quot;radio&quot; v-model=&quot;radio&quot; value=&quot;list&quot;&gt;list &lt;keep-alive&gt; &lt;component :is=&quot;radio&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031let home=&#123; template:&#x27;&lt;div&gt;home&lt;/div&gt;&#x27;, mounted()&#123; alert(&#x27;home&#x27;); &#125;, beforeDestroy()&#123; alert(&#x27;销毁&#x27;); &#125;&#125;;let list=&#123; template:&#x27;&lt;div&gt;list&lt;/div&gt;&#x27;, mounted()&#123; alert(&#x27;list&#x27;); &#125;, beforeDestroy()&#123; alert(&#x27;销毁&#x27;); &#125;&#125;;let vm = new Vue(&#123; el:&#x27;#app&#x27;, components:&#123; home,list &#125;, data:&#123; radio:home &#125;, mounted()&#123; alert(&#x27;vm&#x27;); &#125;&#125;); router​ 访问不同的路径，返回不同的结果，常用于单页面应用（spa,single page application），单页面应用常用开发模式： hash模式：开发时使用，不会导致404，但是不支持SEO h5的history.pushStatus：上线使用 使用123456&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot; tag=&quot;button&quot;&gt;home&lt;/router-link&gt; &lt;router-link to=&quot;/list&quot; tag=&quot;button&quot;&gt;list&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;!--router-view是一个全局组件，可以直接使用--&gt;&lt;/div&gt; 1234567891011121314151617181920212223let home = &#123; template: &#x27;&lt;div&gt;首页&lt;/div&gt;&#x27;&#125;;let list = &#123; template: &#x27;&lt;div&gt;列表页&lt;/div&gt;&#x27;&#125;;let routes = [ //路由的映射表，配置路径和组件的关系 &#123;path: &#x27;/home&#x27;, component: home&#125;, //配置的关系就是页面级组件 &#123;path: &#x27;/list&#x27;, component: list&#125; //路径必须加斜线];let router = new VueRouter(&#123; //引入vue-router自带VueRouter类 //mode:&#x27;history&#x27;, //h5模式 routes, linkActiveClass:&#x27;active&#x27;&#125;);let vm = new Vue(&#123; el: &#x27;#app&#x27;, router&#125;); 多级路由123456789101112&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/detail&quot;&gt;详情&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;template id=&quot;detail&quot;&gt; &lt;div&gt; &lt;router-link to=&quot;/detail/profile&quot;&gt;个人信息&lt;/router-link&gt; &lt;router-link to=&quot;/detail/about&quot;&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 12345678910111213141516171819202122232425262728293031323334353637383940let home = &#123; template: &#x27;&lt;div&gt;home&lt;/div&gt;&#x27;&#125;;let detail = &#123; template: &#x27;#detail&#x27;&#125;;let profile = &#123; template: &#x27;&lt;div&gt;profile&lt;/div&gt;&#x27;&#125;;let about = &#123; template: &#x27;&lt;div&gt;about&lt;/div&gt;&#x27;&#125;;let routes = [ &#123; path: &#x27;/home&#x27;, component: home &#125;, &#123; path: &#x27;/detail&#x27;, component: detail, children: [ //child中路径永远不带/，带/表示是1级路由 &#123;path: &#x27;profile&#x27;, component: profile&#125;, &#123;path: &#x27;about&#x27;, component: about&#125;, ] &#125;];let router = new VueRouter(&#123; routes&#125;);let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, router&#125;); 路由参数1234567&lt;div id=&quot;app&quot;&gt; &lt;!--如果使用对象作为to的属性值，并且使用了参数，必须给路由起名，并通过名字跳转--&gt; &lt;router-link :to=&quot;&#123;name:&#x27;pro&#x27;,params:&#123;c:1,a:2&#125;&#125;&quot;&gt;商品1&lt;/router-link&gt; &lt;router-link to=&quot;/article/2/b&quot;&gt;商品2&lt;/router-link&gt; &lt;router-link to=&quot;/article/3/c&quot;&gt;商品3&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627let article = &#123; template: &#x27;&lt;div&gt;第 &#123;&#123;$route.params.c&#125;&#125; 篇文章&lt;/div&gt;&#x27;, watch: &#123; //路径参数发生变化，通过监控参数变化来发送ajax $route() &#123; //路径每次变化，$route每次重新赋值 alert(&#x27;发送ajax请求&#x27;); &#125; &#125;&#125;;// /article/1/a 匹配出一个对象// /article/:c/:a =&gt; &#123;c:1,a:&#x27;a&#x27;&#125; = this.$route.paramslet routes = [ &#123; path: &#x27;/article/:c/:a&#x27;, component: article, name: &#x27;pro&#x27; &#125;];let router = new VueRouter(&#123; routes&#125;);let vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123;&#125;, router&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://www.ryanshang.com/tags/Vue/"}]},{"title":"React学习笔记","slug":"React学习笔记","date":"2017-06-15T16:00:00.000Z","updated":"2018-08-11T10:21:50.165Z","comments":true,"path":"2017/06/16/React学习笔记/","link":"","permalink":"https://www.ryanshang.com/2017/06/16/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"JSX​ JSX是react发明的特殊写法语法，JSX&#x3D;JavaScript+XML，就是JS和HTML的混合写法，这并不是JS引擎原生支持的，所以想在浏览器中直接执行，需要先转成ES5代码。jsx本质上就是一个js变量，可以作为参数、函数返回值、也可以用在循环&#x2F;判断语句中。 1234ReactDOM.render( &lt;h1 id=&quot;msg&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/h1&gt;, document.querySelector(&#x27;#root&#x27;)); 转义成为： 123456789101112131415//1参数是元素类型，2参数是属性对象，3参数是子元素ReactDom.render(React.createElement( &quot;h1&quot;, &#123; id: &quot;msg&quot; &#125;, React.createElement( &quot;span&quot;, null, &quot;hello&quot; ), React.createElement( &quot;span&quot;, null, &quot;world&quot; )), document.querySelector(&#x27;#root&#x27;));","text":"JSX​ JSX是react发明的特殊写法语法，JSX&#x3D;JavaScript+XML，就是JS和HTML的混合写法，这并不是JS引擎原生支持的，所以想在浏览器中直接执行，需要先转成ES5代码。jsx本质上就是一个js变量，可以作为参数、函数返回值、也可以用在循环&#x2F;判断语句中。 1234ReactDOM.render( &lt;h1 id=&quot;msg&quot;&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;/h1&gt;, document.querySelector(&#x27;#root&#x27;)); 转义成为： 123456789101112131415//1参数是元素类型，2参数是属性对象，3参数是子元素ReactDom.render(React.createElement( &quot;h1&quot;, &#123; id: &quot;msg&quot; &#125;, React.createElement( &quot;span&quot;, null, &quot;hello&quot; ), React.createElement( &quot;span&quot;, null, &quot;world&quot; )), document.querySelector(&#x27;#root&#x27;)); 原理： 1234567891011121314151617//createElement方法执行后会返回一个虚拟DOM对象function createElement(type, props, children) &#123; return &#123;type, props: &#123;...props, children&#125;&#125;;&#125;//把一个虚拟DOM变成真实DOM并插入容器内部function render(virtualDOM, container) &#123; let ele = document.createElement(virtualDOM.type); for (let attr in virtualDOM.props) &#123; if (attr === &#x27;children&#x27;) &#123; ele.innerHTML = virtualDOM.props[attr]; &#125; else &#123; ele.setAttribute(attr, virtualDOM.props[attr]); &#125; container.appendChild(ele); &#125;&#125; ReactDom渲染过程： 把jsx元素转成React.createElement方法的调用 createElement会返回一个虚拟DOM对象 render方法负责把虚拟DOM对象转换成真实DOM对象，并插入到容器内部 jsx规则： 如果需要换行的话，需要把jsx放在小括号里 如果想在js中显示js变量，需要放入大括号，里面可以放入js表达式 表达式中不能放对象，可以放字符串、数字等，还可以放函数的调用 jsx react元素的属性： 普通属性 特殊属性 class &#x3D;&gt; className for &#x3D;&gt; htmlFor 如果属性名是多个单词的话，驼峰命名法 z-index &#x3D;&gt; zIndex tab-index &#x3D;&gt; tabIndex react元素有一个非常重要的属性叫children，指这个元素的所有子元素 jsx设置事件：​ 给react元素设置属性 on+事件名，事件名开头大写。 1&lt;div onClick=&#123;fn&#125;&gt; ref：​ ref的值是一个函数，当这个DOM挂载到页面之后会执行绑定的函数，参数就是此react元素对应的真实DOM元素。 12//当这个input的虚拟DOM转成真实的并插入到页面中后，会调用元素的ref函数，并且把这个真实DOM作为参数传到函数中&lt;input type=&quot;text&quot; id=&quot;username&quot; required ref=&#123;input =&gt; &#123;console.log(input)&#125;&#125;/&gt; 组件​ 组件就像一个纯函数，接受任意参数，返回一个并且只有一个react元素。声明组件有两种方式：函数组件和类组件。 渲染组件的过程： 初始化属性对象，然后调用类的构造函数，并把类的属性对象传进去，得到组件的实例 会调用实例的render方法，得到返回的react元素 render方法会把react元素渲染成真实的DOM元素，并挂载到容器内部 函数式组件： 1. 接受一个props参数，是一个对象 2. 组件名称必须首字母大写，render只能通过首字母判断是元素还是组件（组件和元素使用方式完全相同，但渲染和使用方式不同，元素之间渲染，组件渲染返回值） 3. 组件函数要返回并且只能返回一个顶级react元素 4. 函数组件没有实例，也没有this 1234567function Welcome(props) &#123; if (props.username) &#123; return &lt;h1&gt;hello &#123;props.username&#125;&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;hello stranger&lt;/h1&gt; &#125;&#125; 类组件： 必须继承自React.Component 类组件是有实例的，需要通过this来调用属性 传给组件的属性会全部封装到一个对象中作为实参传给组件对象 123456789101112131415161718192021class Welcome extends React.Component &#123; render() &#123; if (this.props.username) &#123; return &lt;h1&gt;hello &#123;this.props.username&#125;&lt;/h1&gt; &#125; else &#123; return &lt;h1&gt;hello stranger&lt;/h1&gt; &#125; &#125;&#125;class App extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;Welcome username=&quot;Ryan&quot;/&gt; &lt;Welcome username=&quot;Jarvan&quot;/&gt; &lt;Welcome username=&quot;Wen&quot;/&gt; &lt;/div&gt; ) &#125;&#125; 组件的属性和状态： 组件的属性是由父组件传入的，状态的值时内部初始化的 组件的属性不能修改， 状态的值是可以修改的 组件的值自己不能改，但是父组件可以改 组件的状态是内部初始化的，只能组件内部修改，外部不能修改 组件的属性和状态都是当前组件的数据源 组件的属性是可以自上而下流动的。单项数据流，只能父传子，只能子传父，也不能兄弟之间传递 给组件传入属性对象的一种方式：1ReactDOM.render(&lt;Comment &#123;...comment&#125;/&gt;, document.querySelector(&#x27;#root&#x27;)); 组件中循环列表：​ 遍历列表需要给每一项设置key属性 1234567891011121314151617181920const lessons = [ &#123;title: &#x27;Lesson 1: title&#x27;, description: &#x27;Lesson 1: description&#x27;&#125;, &#123;title: &#x27;Lesson 2: title&#x27;, description: &#x27;Lesson 2: description&#x27;&#125;, &#123;title: &#x27;Lesson 3: title&#x27;, description: &#x27;Lesson 3: description&#x27;&#125;, &#123;title: &#x27;Lesson 4: title&#x27;, description: &#x27;Lesson 4: description&#x27;&#125;];class LessonsList extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123;this.props.lessons.map((item, index) =&gt; &#123; return ( &lt;Lesson lesson=&#123;item&#125; index=&#123;index&#125; key=&#123;index&#125;/&gt; ) &#125;)&#125; &lt;/div&gt; ) &#125;&#125; state​ 组件的状态用来描述组件内部可以变化的数据。组件的状态是类组件所特有的。当类实例化的时候，会自动调用构造函数，我们可以在构造函数中初始化状态对象。 1234567class Clock extends React.Component &#123; constructor(props) &#123; super(props); //super指向父类的构造函数 this.props=props //当一个类继承另一个类时，需要先调用父类的构造函数 this.state = &#123;time: new Date()&#125; &#125;&#125; ​ 修改state需要掉用实例的setState方法，setState方法用来修改状态，传入一个增量对象，会覆盖同名属性或增加新属性，不会删除老的属性。调用setState不但会修改状态，还会重新调用render方法。除了构造函数外，永远不要直接操作state。 ​ 为了提高性能，react可能会把多个setState调用合并成一个。 123componentDidMount() &#123; this.setState(&#123;time: new Date()&#125;); &#125; ​ 注意，setState方法是一个异步方法。 1234567891011this.setState((prevState) =&gt; (&#123;number: prevState.number + 1&#125;));this.setState((prevState) =&gt; (&#123;number: prevState.number + 2&#125;));this.setState((prevState) =&gt; (&#123;number: prevState.number + 3&#125;));//等价于 =&gt;this.setState(&#123;number: this.state.number+1&#125;,()=&gt;&#123; this.setState(&#123;number: this.state.number+2&#125;,()=&gt;&#123; this.setState(&#123;number: this.state.number+3&#125;,()=&gt;&#123; console.log(this.state.number); &#125;); &#125;);&#125;); 兄弟间传递数据——状态提升：​ 要让两个兄弟之间传递数据，需要找到他们最近的共同祖先，然后在共同祖先组件中定义一个特权函数，子孙组件通过这个共同祖先组件的特权方法，可以改变这个共同祖先的state状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Input extends React.Component &#123; handleChange(event) &#123; let percent = event.target.value; this.props.setPercent(percent); &#125; render() &#123; //给一个输入框一个value值，会变成只读的 return ( &lt;div&gt; &lt;input type=&#x27;number&#x27; onChange=&#123;this.handleChange.bind(this)&#125; value=&#123;this.props.percent&#125;/&gt; &lt;/div&gt; ) &#125;&#125;class PercentageShower extends React.Component &#123; render() &#123; return ( &lt;div&gt; &#123; (parseFloat(this.props.percent)*100).toFixed(2)+&#x27;%&#x27; &#125; &lt;/div&gt; ) &#125;&#125;//要让两个兄弟之间传递数据，需要找到他们最近的共同祖先class PercentageApp extends React.Component &#123; constructor() &#123; super(); this.state = &#123;percent: 0.00&#125;; &#125; //定义了一个可以改变父组件中状态对象中percent的方法 setPercent = (percent) =&gt; &#123; this.setState(&#123;percent: percent&#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;Input percent=&#123;this.state.percent&#125; setPercent=&#123;this.setPercent&#125;/&gt; &lt;PercentageShower percent=&#123;this.state.percent&#125;/&gt; &lt;/div&gt; ) &#125;&#125; 生命周期componentWillReceiveProps: 将要接收属性 componentWillMount: 组件将要挂载 componentDidMount: 组件完成挂载 componentWillUpdate: 组件即将更新 componentDidUpdate: 组件完成更新 componentWillUnmount: 组件即将销毁 shouldComponentUpdate: 询问组件是否更新 12345678shouldComponentUpdate(prevProps, prevState) &#123; console.log(&#x27;询问组件是否更新&#x27;); if (prevState.number &lt; 10) &#123; return true; &#125; else &#123; return false; &#125;&#125; Router​ Router是路由的容器。 开始使用​ 安装react-router-dom 1$ npm install react-router-dom ​ 引入react-router-dom并使用 123456789import &#123;HashRouter as Router,&#125; from &#x27;react-router-dom&#x27;;//需要使用路由功能的部分需要被Router组件包裹起来ReactDOM.render( &lt;Router&gt; &lt;div&gt; ... &lt;/div&gt; &lt;/Router&gt;, document.querySelector(&#x27;#root&#x27;)); Router组件会给他的所有子组件传递三个属性： history 是用来操作历史 goBack 返回上一个路径 push 跳转路径 location 路径 pathname 路径名 state 路径状态 match 匹配上有值，匹配不上为null isExact 是否精确匹配 params 路径参数 path 来自于路由里的path属性 url 来自于url地址中的# 当有路径参数的时候path和url不一样 RouteRoute是路由规则 基本使用使用时，首先使用Link组件实现跳转（类似于Vue中的router-link），然后使用Route组件，通过传入path和component属性，匹配路径默认匹配前缀，只要当前url路径和path的前缀相同就表示能匹配上，然后渲染对应的组件（一组Route类似于Vue中的router-view)。 需要精确匹配，需要给Route组建设置exact属性。 123456789101112131415161718192021import &#123; HashRouter as Router, Route, Link&#125; from &#x27;react-router-dom&#x27;;//path 路由//component 组件名称ReactDOM.render( &lt;Router&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to=&quot;/profile&quot;&gt;个人&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt; &lt;Route path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt; &lt;/div&gt; &lt;/Router&gt;, document.querySelector(&#x27;#root&#x27;)); Link组件中的to属性也可以写作一个对象 123456&lt;Link to=&#123;&#123; pathname: &#x27;/courses&#x27;, search: &#x27;?sort=name&#x27;, hash: &#x27;#the-hash&#x27;, state: &#123; fromDashboard: true &#125;&#125;&#125;/&gt; Switch如果希望最多指向一个组件，则需要把若干个路由由switch包裹起来。 12345&lt;Switch&gt; &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt; &lt;Route path=&quot;/user&quot; component=&#123;User&#125;/&gt; &lt;Route path=&quot;/login&quot; component=&#123;Login&#125;/&gt;&lt;/Switch&gt; 路由组件渲染三种方法 component &#x3D; 组件 1&lt;Route path=&quot;/&quot; component=&#123;Home&#125;/&gt; render 是一个函数，返回值是一个组件，路径匹配则渲染 ​ 因为返回的组件不是Router组件的子组件，所以没有Router组件传递过来的三个属性，可用withRouter组件解决，也可直接给返回的组件传入三个属性 1234//rest=&#123;path:&quot;/profile&quot;&#125;&lt;Route &#123;...rest&#125; render=&#123;(&#123;location,history,match&#125;) =&gt; ( &lt;Profile history=&#123;history&#125;/&gt; :)&#125;/&gt; children 是一个函数，返回一個React DOM元素，无论匹不匹配都渲染 123&lt;Route path=&#123;to&#125; children=&#123;(&#123;match&#125;) =&gt; ( &lt;li className=&#123;match ? &quot;active&quot; : &quot;&quot;&#125;&gt;&lt;Link to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;&lt;/li&gt;)&#125;/&gt; URL参数在Route中，设置路径参数，在Link组件中直接访问按照需要的路径参数跳转链接即可。 123&lt;Route path=&quot;/user/detail/:id&quot; component=&#123;UserDetail&#125;/&gt;&lt;Link to=&#123;&#123;pathname: `/user/detail/$&#123;user.id&#125;`, state: &#123;user&#125;&#125;&#125;&gt;&#123;user.username&#125;&lt;/Link&gt; 认证保护路由受保护路由是指如果当前用户未登录，则不能访问被保护的路由。 原理是利用Route组件的render渲染方式，根据条件判断渲染不同组件。 12345678910111213//ProtectedRoute.jsexport default (&#123;component: Component, ...rest&#125;) =&gt; &#123; return ( &lt;Route &#123;...rest&#125; render=&#123;(&#123;location&#125;) =&gt; ( localStorage.getItem(&#x27;login&#x27;) ? &lt;Component/&gt; : &lt;Redirect to=&#123;&#123;pathname: &quot;/login&quot;, state: &#123;from: location.pathname&#125;&#125;&#125;/&gt; )&#125;/&gt; )&#125;//使用时&lt;ProtectedRoute path=&quot;/profile&quot; component=&#123;Profile&#125;/&gt; 自定义链接利用Route组件的children渲染方式，对组件进行操作。 12345678//MenuLink.jsexport default (&#123;to, children,&#125;) =&gt; &#123; return ( &lt;Route exact path=&#123;to&#125; children=&#123;(&#123;match&#125;) =&gt; ( &lt;li className=&#123;match ? &quot;active&quot; : &quot;&quot;&#125;&gt;&lt;Link to=&#123;to&#125;&gt;&#123;children&#125;&lt;/Link&gt;&lt;/li&gt; )&#125;/&gt;)&#125;; 阻止导航使用Prompt组件，当when属性的值为true的时候，弹出confirm框。 12345import &#123;Prompt&#125; from &#x27;react-router-dom&#x27;;&lt;Prompt when=&#123;this.state.isEditing&#125; message=&#123;location =&gt; `切换到$&#123;location.pathname&#125;？`&#125;/&gt; 未匹配一般放在路由规则最后，配合Switch组件使用，用于404场景。 1&lt;Route component=&#123;NoMatch&#125;/&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"https://www.ryanshang.com/tags/React/"}]},{"title":"JS中两个等号的比较","slug":"JS中两个等号的比较","date":"2017-06-06T16:00:00.000Z","updated":"2018-08-11T10:21:50.165Z","comments":true,"path":"2017/06/07/JS中两个等号的比较/","link":"","permalink":"https://www.ryanshang.com/2017/06/07/JS%E4%B8%AD%E4%B8%A4%E4%B8%AA%E7%AD%89%E5%8F%B7%E7%9A%84%E6%AF%94%E8%BE%83/","excerpt":"​ 以前在学习JavaScript时总是有些漏洞，比如JavaScript中两个等号的比较所带来的类型转换问题，今天特别拿出来研究整理了一下。 对象&#x3D;&#x3D;对象引用类型的数据比较的是引用地址 12&#123;&#125;==&#123;&#125;; //false，引用地址不同[]==[]; //false，引用地址不同 对象&#x3D;&#x3D;字符串","text":"​ 以前在学习JavaScript时总是有些漏洞，比如JavaScript中两个等号的比较所带来的类型转换问题，今天特别拿出来研究整理了一下。 对象&#x3D;&#x3D;对象引用类型的数据比较的是引用地址 12&#123;&#125;==&#123;&#125;; //false，引用地址不同[]==[]; //false，引用地址不同 对象&#x3D;&#x3D;字符串对象通过toString()转换成字符串 1234[].toString(); //&#x27;&#x27;(&#123;&#125;).toString(); //[Object Object][]==&#x27;&#x27;; //true(&#123;&#125;)==&#x27;abc&#x27;; //false 对象&#x3D;&#x3D;数字对象先通过toString()转换成字符串，字符串再通过Number()转换成数字 1[1]==1; //true [1]=&gt;&#x27;1&#x27;,&#x27;1&#x27;=&gt;1 对象&#x3D;&#x3D;布尔左右两边先统一转换成数字类型再进行比较 1[]==true; //false []=&gt;0,true=&gt;1 字符串&#x3D;&#x3D;数字把字符串转换成数字再进行比较 1&#x27;abc&#x27;==NaN; //false &#x27;abc&#x27;=&gt;NaN NaN和NaN不相等 字符串&#x3D;&#x3D;布尔左右两边先转化成数字再比较 1&#x27;1&#x27;==true; //true &#x27;1&#x27;=&gt;1,true=&gt;1 数字&#x3D;&#x3D;布尔布尔类型转换成数类型再进行比较 1true==3; //false true=&gt;1 NaN&#x3D;&#x3D;NaNNaN和任何数(包括自己)比较时都返回false 1NaN==NaN; //false null&#x3D;&#x3D;undefined左右两边不做数据类型转换，返回结果为true 1null==undefined; //true null和undefined没有toString()方法，和任何数去比较，返回结果都为false。和自身比较返回true。 1null==false; //false ​ 按照我的想法，两个等号比较，大致上类型转换的思路是： 对象和对象间比较引用地址 对象和三种基本数据类型转换，先转换成字符串，如果需要则继续转换则数字 三种基本数据类型转换成数字再进行比较 null和undefined和除了自身任何数比较都为false NaN任何时候比较都返回false ​ JavaScript中的这种隐式数据类型转换，有些时候确实会带来一些问题。为了减少这些问题对代码产生影响，我决定尽量少用相等，多用全等以便去更好的控制数据类型。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"}]},{"title":"mongoose中关于user表的问题","slug":"mongoose中关于user表的问题","date":"2017-05-06T16:00:00.000Z","updated":"2024-01-07T11:58:50.332Z","comments":true,"path":"2017/05/07/mongoose中关于user表的问题/","link":"","permalink":"https://www.ryanshang.com/2017/05/07/mongoose%E4%B8%AD%E5%85%B3%E4%BA%8Euser%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"​ 最近在做毕业设计，后台采用Node.js+Express，数据库采用MongoDB，连接数据库采用的Mongoose中间件。 ​ 在连接数据库时出现了这样一个问题，按照我的需要，数据库中有一个数据集合用来储存用户信息，表名为user。后来发现无论如何都获取不到user集合中的数据，在MondoDB的控制台程序中也获取不到。 ​ 最后安装了RoboMongo这个MongoDB可视化工具才发现，数据库中user数据的名字变成了users，user数据集是个空数据集。 ​ 这应该算是Mongoose插件的一个bug吧。","categories":[{"name":"后端","slug":"后端","permalink":"https://www.ryanshang.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.ryanshang.com/tags/MongoDB/"}]}],"categories":[{"name":"Windows","slug":"Windows","permalink":"https://www.ryanshang.com/categories/Windows/"},{"name":"Linux","slug":"Linux","permalink":"https://www.ryanshang.com/categories/Linux/"},{"name":"前端","slug":"前端","permalink":"https://www.ryanshang.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Mac","slug":"Mac","permalink":"https://www.ryanshang.com/categories/Mac/"},{"name":"工具","slug":"工具","permalink":"https://www.ryanshang.com/categories/%E5%B7%A5%E5%85%B7/"},{"name":"后端","slug":"后端","permalink":"https://www.ryanshang.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"心情","slug":"心情","permalink":"https://www.ryanshang.com/categories/%E5%BF%83%E6%83%85/"}],"tags":[{"name":"开发环境","slug":"开发环境","permalink":"https://www.ryanshang.com/tags/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"name":"WSL","slug":"WSL","permalink":"https://www.ryanshang.com/tags/WSL/"},{"name":"HTTPS","slug":"HTTPS","permalink":"https://www.ryanshang.com/tags/HTTPS/"},{"name":"Nginx","slug":"Nginx","permalink":"https://www.ryanshang.com/tags/Nginx/"},{"name":"CSS","slug":"CSS","permalink":"https://www.ryanshang.com/tags/CSS/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.ryanshang.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://www.ryanshang.com/tags/Homebrew/"},{"name":"npm","slug":"npm","permalink":"https://www.ryanshang.com/tags/npm/"},{"name":"node-sass","slug":"node-sass","permalink":"https://www.ryanshang.com/tags/node-sass/"},{"name":"Charles","slug":"Charles","permalink":"https://www.ryanshang.com/tags/Charles/"},{"name":"Git","slug":"Git","permalink":"https://www.ryanshang.com/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://www.ryanshang.com/tags/Hexo/"},{"name":"小知识","slug":"小知识","permalink":"https://www.ryanshang.com/tags/%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"name":"HTTP","slug":"HTTP","permalink":"https://www.ryanshang.com/tags/HTTP/"},{"name":"代理","slug":"代理","permalink":"https://www.ryanshang.com/tags/%E4%BB%A3%E7%90%86/"},{"name":"iOS","slug":"iOS","permalink":"https://www.ryanshang.com/tags/iOS/"},{"name":"Node","slug":"Node","permalink":"https://www.ryanshang.com/tags/Node/"},{"name":"TypeOrm","slug":"TypeOrm","permalink":"https://www.ryanshang.com/tags/TypeOrm/"},{"name":"Zsh","slug":"Zsh","permalink":"https://www.ryanshang.com/tags/Zsh/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.ryanshang.com/tags/Ubuntu/"},{"name":"CentOS","slug":"CentOS","permalink":"https://www.ryanshang.com/tags/CentOS/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://www.ryanshang.com/tags/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"},{"name":"心情","slug":"心情","permalink":"https://www.ryanshang.com/tags/%E5%BF%83%E6%83%85/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.ryanshang.com/tags/JavaScript/"},{"name":"面试题","slug":"面试题","permalink":"https://www.ryanshang.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"Vue","slug":"Vue","permalink":"https://www.ryanshang.com/tags/Vue/"},{"name":"Vue Cli","slug":"Vue-Cli","permalink":"https://www.ryanshang.com/tags/Vue-Cli/"},{"name":"转载","slug":"转载","permalink":"https://www.ryanshang.com/tags/%E8%BD%AC%E8%BD%BD/"},{"name":"单元测试","slug":"单元测试","permalink":"https://www.ryanshang.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"小程序","slug":"小程序","permalink":"https://www.ryanshang.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"Chromebook","slug":"Chromebook","permalink":"https://www.ryanshang.com/tags/Chromebook/"},{"name":"React","slug":"React","permalink":"https://www.ryanshang.com/tags/React/"},{"name":"MongoDB","slug":"MongoDB","permalink":"https://www.ryanshang.com/tags/MongoDB/"}]}